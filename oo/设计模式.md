# 设计模式

## 策略模式

定义算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。

==p24、p28==

---

## 单例模式

单例对象的类必须保证只有一个实例存在，全局有唯一接口访问。

**分类**：　　

懒汉方式：指全局的单例实例在第一次被使用时构建。
饿汉方式：指全局的单例实例在类装载时构建。

**参考**：[golang单例模式](https://studygolang.com/articles/11444)

---

## 面向对象设计原则

### 开放 - 封闭原则

模块应该既是开放的又是封闭的。(不要需改已有的抽象类、接口和实现类，可以增加新的实现类)

- 软件模块对于扩展是开放的：模块的行为可以扩展，当应用的需求改变时，可以对模块进行扩展，以满足新的需求。

- 软件模块对于修改是封闭的：对模块行为扩展时，不必改动模块的源代码或二进制代码。

不能修改已有的软件模块（即修改封闭），从而不影响依赖于该模块的其他模块；通过对已有模块扩展新模块功能（即扩展开放），从而应对需求变更或新需求

**举例**：

该例子中如果 windows 访问类直接访问具体主题1（Specific Subject1），那么它就违反了开放封闭原则

![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1geatqxfr20j311q0jwdjy.jpg)

**好处**：

1. 对软件测试的影响
软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。

2. 可以提高代码的可复用性
粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。

3. 可以提高软件的可维护性
遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。

**参考**：[开闭原则——面向对象设计原则](http://c.biancheng.net/view/1322.html)

### 里氏替换原则

子类型（subtype）必须能够替换它们的基类型（base type）。

**子类可以扩展父类的功能，但不能改变父类原有的功能**。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。

若对每个类型 S 的对象 O1，都存在一个类型 T 的对象 O2，使得在所有针对 T 编写的程序 P 中，用 O1 替换 O2后，程序 P 的行为不变，则 S 是 T 的子类型。

举例（正方形继承长方形的错误）：

![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1geas57h8ffj307s0e5zkk.jpg)

长方形类中有四个方法，分别是 SetHeight 设置高、SetWidth 设置宽、GetHeight 获得高以及 GetWidth 获得宽。

继承长方形的正方形中对 SetHeight 和 SetWidth 进行重写，比如 SetHeight 中会将高和宽设置为相等。

此时有一个 Resize(Rectangle) 方法，输入一个长方形对象，要求高必须大于宽，实现如下：

![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1geaswd5o8pj30ew06iaa6.jpg)

此时如果传入一个 Square 对象，**会出现死循环，最终导致浮点溢出**

为此，需要将类图修改为：

![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1geasy07ploj30gk0em755.jpg)

**好处**：

1. 里氏替换原则是实现开闭原则的重要方式之一。
它克服了继承中重写父类造成的可复用性变差的缺点。

2. 它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。

**参考**：

- [里氏替换原则——面向对象设计原则](里氏替换原则——面向对象设计原则)

- [设计原则（二）里氏替换原则（LSP）](设计原则（二）里氏替换原则（LSP）)

### 依赖倒置

**高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节（实现类），细节应该依赖抽象。其核心思想是：要面向接口编程，不要面向实现（实现类）编程。**

依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。

由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。

使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。

**好处**：

- 依赖倒置原则可以降低类间的耦合性。

- 依赖倒置原则可以提高系统的稳定性。

- 依赖倒置原则可以减少并行开发引起的风险。

- 依赖倒置原则可以提高代码的可读性和可维护性。

**举例**：链接中有案例，“顾客购物程序”例子。

**参考**：

- [依赖倒置原则——面向对象设计原则](依赖倒置原则——面向对象设计原则)

### 单一职责

**单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分**。

该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：

1. 一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；

2. 当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。

**优点**：单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。

- 降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。

- 提高类的可读性。复杂性降低，自然其可读性会提高。

- 提高系统的可维护性。可读性提高，那自然更容易维护了。

- 变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。

**举例**：链接二中有例子，数据库增删改查操作类和权限验证类分开，不能写在一起

**参考**：

- [单一职责原则——面向对象设计原则](单一职责原则——面向对象设计原则)

- [OO案例分析—单一职责原则](https://www.cnblogs.com/binb/archive/2012/09/02/zoubin_srp.html?utm_source=tuicool&utm_medium=referral)

### 接口隔离

**要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。**

客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。

以上两个定义的含义是：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用

**优点**：接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。

- 将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。

- 接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。

- 如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。

- 使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。

- 能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。

**参考**：

- [接口隔离原则——面向对象设计原则](http://c.biancheng.net/view/1330.html)

