# 七牛云面经

**参考**：[https://www.nowcoder.com/discuss/145338?type=post&order=time&pos=&page=1](https://www.nowcoder.com/discuss/145338?type=post&order=time&pos=&page=1)

### 1. map如何顺序读取

go语言的map是无序的，多次遍历map的结果可能是不同的

```go
package main
import (
	"fmt"
)
// GetMap 得到map
func GetMap() (result map[int]uint32) {
	result = map[int]uint32{}
	// 压入各个数据
	result[24] = 223
	result[17] = 91
	result[9] = 13
	result[11] = 330
	result[55] = 100
	return
}
func main() {
	mapResu := GetMap()
	// 遍历map
	for key, value := range mapResu {
		fmt.Printf("key = %v,value = %v\n", key, value)
	}
}
```

第一次遍历结果如下：

```go
key = 17,value = 91
key = 9,value = 13
key = 11,value = 330
key = 55,value = 100
key = 24,value = 223
```

第二次遍历结果如下：

```go
key = 55,value = 100
key = 24,value = 223
key = 17,value = 91
key = 9,value = 13
key = 11,value = 330
```

可以看到两次遍历的结果是不同的

**原因**：map底层使用 hash 表实现，插入数据位置是随机的，所以遍历过程中新插入的数据不能保证遍历到。java 语言每次都会按照顺序遍历桶，而go语言会提前取一个随机数，把桶的遍历顺序随机化。`之所以这样设计`，是因为如果没有设置这个随机数，那么在大多数情况下，golang会表现出map的顺序是固定的情况。但是golang底层并没有保证这一点，或许(现在/以后)会有特殊情况出现顺序不固定的情况。担心开发者们误解这一点，golang就特意去打乱了这个顺序，让开发者们知道golang底层不保证map每次遍历都是同一个顺序。

#### 解决方法

1. 对key排序，再遍历key输出value

   ```go
   package main
   import (
   	"fmt"
   	"sort"
   )
   // GetMap 得到map及其所有的key
   // keys : map中所有的key，已排序，从小到大
   func GetMap() (result map[int]uint32, keys []int) {
   	result = map[int]uint32{}
   	keys = []int{}
   	// 压入各个数据
   	result[24] = 223
   	result[17] = 91
   	result[9] = 13
   	result[11] = 330
   	result[55] = 100
   	// 得到各个key
   	for key := range result {
   		keys = append(keys, key)
   	}
   	// 给key排序，从小到大
   	sort.Sort(sort.IntSlice(keys))
   	// 给key排序，从大到小
   	//sort.Sort(sort.Reverse(sort.IntSlice(keys)))
   	return
   }
    
   func main() {
   	mapResu, keys := GetMap()
   	// 注意：遍历keys，而不是遍历map
   	for _, key := range keys {
   		fmt.Printf("key = %v,value = %v\n", key, mapResu[key])
   	}
   }
   // key = 9,value = 13
   // key = 11,value = 330
   // key = 17,value = 91
   // key = 24,value = 223
   // key = 55,value = 100
   ```

   2. 思路是直接不用map，用struct存放key和value，实现sort接口，就可以调用sort.Sort进行排序了

   **参考**：

   - [go语言map按照key，value进行排序](https://blog.csdn.net/yzf279533105/article/details/81087848)
   - [go语言中map每次遍历的顺序不同-问题分析](https://www.cnblogs.com/noKing/p/11661567.html)

---

### 2. 实现 map

#### 需求

对于Set类型的数据结构，其实本质上跟List没什么多大的区别。无非是Set不能含有重复的Item的特性，Set有初始化、Add、Clear、Remove、Contains等操作

#### 定义

Set的Value为固定的值，用一个常量替代即可。所以用一个空结构体来实现的，如下所示：

```go
// 空结构体
var Exists = struct{}{}
// Set is the main interface
type Set struct {
 // struct为结构体类型的变量
 m map[interface{}]struct{}
}
```

空结构体变量的内存大小为0。空结构体变量之间彼此相等，地址也相等。

#### 初始化

Set类型数据结构的初始化操作，在声明的同时可以选择传入或者不传入进去。声明Map切片的时候，Key可以为任意类型的数据，用空接口来实现即可。Value的话按照上面的分析，用空结构体即可：

```go
func New(items ...interface{}) *Set {
  // 获取Set的地址
 s := &Set{}
 // 声明map类型的数据结构
 s.m = make(map[interface{}]struct{})
 s.Add(items...)
 return s
}
```

#### 添加

简化操作可以添加不定个数的元素进入到Set中，用变长参数的特性来实现这个需求即可，因为Map不允许Key值相同，所以不必有排重操作。同时将Value数值指定为空结构体类型。

```go
func (s *Set) Add(items ...interface{}) error {
 for _, item := range items {
 s.m[item] = Exists
 }
 return nil
}
```

**参考**：[详解Go中Set的实现方式](https://www.jb51.net/article/170043.htm)

---

### 3. go 的调度

**参考**：

- [Go 的并发性与调度器](https://www.jianshu.com/p/56c0c51ab537)

---

### 4. go struct 能不能比较

`同一个struct的2个实例能不能比较 ==  !=`
**答案**：可以能（成员变量都可比较，或使用reflect.DeepEqual()进行比较）、也可以不能（存在成员变量不可比较）

`两个不同的struct的实例能不能比较 ==  !=`
**答案**：可以能（满足强制转换的条件）、也可以不能

虽然答案都一样，但是涉及到的知识点略有不同

**如果结构体的所有成员变量都是可比较的，那么结构体就可比较**

**如果结构体中存在不可比较的成员变量（map、slice 不能比较），那么结构体就不能比较。不过可以用reflect.DeepEqual()进行深度比较。1: 指针1 == 指针2 结果为true、2: 指针1 指针2 所指向的值深度相等。满足1和2其中一条结果为 true**

**结构体之间进行转换需要他们具备完全相同的成员(字段名、字段类型、字段个数)**

**参考**：[Go语言 struct结构体 能比较么 == 或 !=](https://blog.csdn.net/daima_caigou/article/details/91418969)

---

### 5. go defer

#### 基础

defer 是 Go 语言提供的一种用于注册延迟调用的机制：让函数或语句可以在当前函数执行完毕后（包括通过 return 正常结束或者 panic 导致的异常结束）执行。

1. 每次 defer 语句执行的时候，会把函数“压栈”，函数参数会被拷贝下来。
2. 当外层函数退出时，defer 函数按照定义的逆序执行（先进后出）。
3. 如果 defer 执行的函数为 nil, 那么会在最终调用函数的产生 panic。

**不能在defer里面返回值**

#### defer 函数对外部变量的引用

在 defer 函数定义时，对外部变量的引用是有两种方式的，分别是作为函数参数和作为闭包引用。

- 作为函数参数，则在 defer 定义时就把值传递给 defer，并被 cache 起来。
- 作为闭包引用的话，则会在defer 函数真正调用时根据整个上下文确定当前的值。

defer 后面的语句在执行的时候，函数调用的参数会被保存起来，也就是复制了一份。真正执行的时候，实际上用到的是这个复制的变量，因此如果此变量是一个“值”，那么就和定义的时候是一致的。如果此变量是一个“引用”，那么就可能和定义的时候不一致。

**defer 后面跟的是闭包，必然是引用类型的变量。**

```go
func trace(s string) string {
       fmt.Println("entering:",s)
       return s
}

func un(s string) {
       fmt.Println("leaving:",s)
}

func a() {
       defer un(trace("a"))
       fmt.Println("in a")
}

func b() {
       defer un(trace("b"))
       fmt.Println("in b")
       a()
}
func main() {
       b()
}
// entering: b
// in b
// entering: a
// in a
// leaving: a
// leaving: b
```

#### 执行的时机

什么情况下会调用 defer 延迟过的函数呢？

1. 当函数执行了 `return` 语句后
2. 当函数处于 `panicing` 状态，也就是程序中 `panic` 回溯上来到当前函数范围内时

对于第一条，首先要了解到 `return xxx` 不是原子命令，会被拆分成如下三行。

```
返回值 = xxx
调用 defer 函数
空的 return
```

**defer 会被插入到赋值和返回之间执行。** 来看看如何拆解。

```go
func f() (r int) {
     t := 5
     defer func() {
       t = t + 5
     }()
     return t
}
// 拆解后
func f() (r int) {
     t := 5
     r = t // 1. 赋值指令
     func() {
         t = t + 5 // 2. defer 被插入到赋值与返回之间执行，这个例子中返回值 r 没被修改过
     }
     return // 3. 空的 return 指令
}
```

```go
func f() (r int) {
    defer func(r int) {
          r = r + 5
    }(r)
    return 1
}
// 拆解后
func f() (r int) {
     r = 1 // 1. 赋值
     func(r int) {
          r = r + 5 // 2. 这里改的 r 是之前传值传进去的r，不会改变要返回的那个r值
     }(r)
     return // 3. 空的 return
}
```

#### defer 和 闭包

其实面试时候，考察是否掌握了 defer 无非是看 defer 的函数是否是闭包。以及 return 语句的拆解。

```go
func f1() {
	var err error
	defer fmt.Println(err)
	err = errors.New("defer error")
	return
}
func f2() {
	var err error
	defer func() {
			fmt.Println(err)
	}()
	err = errors.New("defer error")
	return
}
func f3() {
	var err error
	defer func(err error) {
			fmt.Println(err)
	}(err)
	err = errors.New("defer error")
	return
}
func main() {
	f1()
	f2()
	f3()
}
// <nil>
// defer error
// <nil>
```

f3() 很多人会搞错，以为也会输出 `defer error`。但只要学会区分什么是闭包，就不会发生拿不准返回值的问题。

#### 使用

##### 资源的释放

一些成对操作，需要回收资源的场景：打开连接/关闭连接；加锁/释放锁；打开文件/关闭文件等。

```go
resA, err:= getA()
if err != nil {
    return
}
// 这里是经典范式：先判断对错，再释放资源。
defer ReleaseA()

resB,err := getB(resA)
if err != nile {
    return
}
defer ReleaseB()
```

##### 异常处理

和 `panic` 以及 `recover` 组合起来模拟 `try...catch` 功能。

```go
func protect(g func()) {
    defer func() {
        log.Println("done")  // Println executes normally even if there is a panic
        if x := recover(); x != nil {
            log.Printf("run time panic: %v", x)
        }
    }()
    log.Println("start")
    g()
}
```

当 `g()` 中通过 panic 抛出错误时，会在 defer 中用 recover 进行捕获。也就是在子函数中的 panic 触发了其处于 panicing 状态，从而当 panic 回溯到当前函数时调用本函数的 defer 修饰的函数。

**Go 官方不建议这么做。**

#### 考题

defer 的面试题一般都会考察 匿名返回值 和 命名返回值 之间的区别。

##### 匿名返回值

```go
func main() {
	fmt.Println("a return:", a()) // 打印结果为 a return: 0
}

func a() int {
	var i int
	defer func() {
		i++
		fmt.Println("a defer2:", i) // 打印结果为 a defer2: 2
	}()
	defer func() {
		i++
		fmt.Println("a defer1:", i) // 打印结果为 a defer1: 1
	}()
	return i
}
// a defer1: 1
// a defer2: 2
// a return: 0
```

匿名返回值是在 return 之前被声明（鉴于类型原因，类型零值为0），defer 无法访问匿名的返回值，因此返回值是 0，而 defer 还是操作之前定义好的变量 i。

##### 命名返回值

```go
func main() {
	fmt.Println("a return:", a()) // 打印结果为 b return: 2
}

func a() (i int) {
	defer func() {
		i++
		fmt.Println("a defer2:", i) // 打印结果为 b defer2: 2
	}()
	defer func() {
		i++
		fmt.Println("a defer1:", i) // 打印结果为 b defer1: 1
	}()
	return i // 或者直接 return 效果相同
}
// a defer1: 1
// a defer2: 2
// a return: 2
```

命名返回值是在函数声明的同时被声明。因此 defer 可以访问命名返回值。return 返回后的值其实是 defer 修改后的值。

**参考**：[Go 中的 defer 详解](http://wjp2013.github.io/go/defer/)

---

### 6. select 可以用于干什么

参考/languages/go/基础知识点.md

---

### 7. 闭包

参考/languages/go/基础知识点.md

---

### 8. go 语言中 context 包的用途

可以用于 `并发控制`

参考/languages/go/并发控制.md

---

### 9. go 语言中 client 如何建立长连接