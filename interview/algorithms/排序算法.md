[toc]

# 排序算法

![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1gc44gj1qytj314m0idmzp.jpg)

## 冒泡排序(BubbleSort)

**基本思想**：两个数比较大小，较大的数下沉，较小的数冒起来。

**过程**：

- 比较相邻的两个数据，如果第二个数小，就交换位置。

- 从后向前两两比较，一直到比较最前两个数据。最终最小数被交换到起始的位置，这样第一个最小数的位置就排好了。

- 继续重复上述过程，依次将第2.3...n-1个最小数排好位置。

![image.png](https://ww1.sinaimg.cn/large/006alGmrly1g9gb98xvdtj30lj0ann3q.jpg)

**平均时间复杂度**：O(n2)

**优化**：

- **针对问题**：
    数据的顺序排好之后，冒泡算法仍然会继续进行下一轮的比较，直到arr.length-1次，后面的比较没有意义的。

- **方案**：
    设置标志位flag，如果发生了交换flag设置为true；如果没有交换就设置为false。
    这样当一轮比较结束后如果flag仍为false，即：这一轮没有发生交换，说明数据的顺序已经排好，没有必要继续进行下去。

---

## 选择排序(SelctionSort)

**基本思想**：
在长度为N的无序数组中，第一次遍历n-1个数，找到最小的数值与第一个元素交换；
第二次遍历n-2个数，找到最小的数值与第二个元素交换；
。。。
第n-1次遍历，找到最小的数值与第n-1个元素交换，排序完成。

**过程**：

![image.png](https://ww1.sinaimg.cn/large/006alGmrly1g9gbd69tzkj30lk0ay0vc.jpg)

**不稳定**：例如 2，2，1

**平均时间复杂度**：O(n2)

---

## 插入排序(Insertion Sort)

**基本思想**：
在要排序的一组数中，假定前n-1个数已经排好序，现在将第n个数插到前面的有序数列中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。

**过程**：

![image.png](https://ww1.sinaimg.cn/large/006alGmrly1g9gbf3jby6j30lz0ie77b.jpg)

**平均时间复杂度**：O(n2)

---

## 希尔排序(Shell Sort)

**前言**：
数据序列1： 13-17-20-42-28 利用插入排序，13-17-20-28-42. Number of swap:1;
数据序列2： 13-17-20-42-14 利用插入排序，13-14-17-20-42. Number of swap:3;
如果数据序列基本有序，使用插入排序会更加高效。

**基本思想**：
在要排序的一组数中，根据某一增量分为若干子序列，并对子序列分别进行插入排序。
然后逐渐将增量减小,并重复上述过程。直至增量为1,此时数据序列基本有序,最后进行插入排序。

**过程**：

![image.png](https://ww1.sinaimg.cn/large/006alGmrly1g9gbmlrb3kj30ki0bntal.jpg)

**平均时间复杂度**：O(n1.5)

---

## 快速排序(Quicksort)

**基本思想**：（分治）

先从数列中取出一个数作为key值；
将比这个数小的数全部放在它的左边，大于或等于它的数全部放在它的右边；
对左右两个小数列重复第二步，直至各区间只有1个数。

**辅助理解**：挖坑填数

![image.png](https://ww1.sinaimg.cn/large/006alGmrly1g9gbsymy07j30m80gx406.jpg)

**不稳定**：例如 2，2，1

**平均时间复杂度**：O(N*logN)

排序数基本有序则不适合快速排序

**快排优化**（参考：[快排的三种优化方式。](https://blog.csdn.net/foreveyking/article/details/81544250)）：

- 在partition中选取pivot时，选取首尾中的进行比较，选取中位数为pivot，以保证pivot能够尽可能的固定在中间，而让两端递归的子数组更加均衡。

---

## 归并排序(Merge Sort)

**基本思想**：
归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。
首先考虑下如何将2个有序数列合并。这个非常简单，只要比较2个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。
解决了上面的合并有序数列问题，再来看归并排序，其的基本思路就是将数组分成2组：A、B，如果这2组组内的数据都是有序的，那么就可以很方便的将这2组数据进行排序。如何让这2组组内数据有序了？
可以将A，B组各自再分成2组。依次类推，当分出来的小组只有1个数据时，可以认为这个小组组内已经达到了有序，然后再合并相邻的2个小组就可以了。这样通过先递归的分解数列，再合并数列就完成了归并排序。

**过程**:

![image.png](https://ww1.sinaimg.cn/large/006alGmrly1g9gbwu3zpnj30gv09njs5.jpg)

**平均时间复杂度**：O(NlogN)
归并排序的效率是比较高的，设数列长为N，将数列分开成小数列一共要logN步，每步都是一个合并有序数列的过程，时间复杂度可以记为O(N)，故一共为O(N*logN)。

## 堆排序(HeapSort)

**基本思想**：

![image.png](https://ww1.sinaimg.cn/large/006alGmrly1g9gctjc68pj30in0n2wke.jpg)

**平均时间复杂度**：O(NlogN)
由于每次重新恢复堆的时间复杂度为O(logN)，共N - 1次重新恢复堆操作，再加上前面建立堆时N / 2次向下调整，每次调整时间复杂度也为O(logN)。二次操作时间相加还是O(N * logN)。

---

## 基数排序(RadixSort)

### BinSort

**基本思想**：
BinSort想法非常简单，首先创建数组A[MaxValue]；然后将每个数放到相应的位置上（例如17放在下标17的数组位置）；最后遍历数组，即为排序后的结果。

**图示**：

![image.png](https://ww1.sinaimg.cn/large/006alGmrly1g9gcz1q7moj30l60cigmn.jpg)

**问题**： 当序列中存在较大值时，BinSort 的排序方法会浪费大量的空间开销。

### RadixSort

**基本思想**： 基数排序是在BinSort的基础上，通过基数的限制来减少空间的开销。

**过程**：

![image.png](https://ww1.sinaimg.cn/large/006alGmrly1g9gd01noj8j30l80me7ae.jpg)

1. 首先确定基数为10，数组的长度也就是10.每个数34都会在这10个数中寻找自己的位置。

2. 不同于BinSort会直接将数34放在数组的下标34处，基数排序是将34分开为3和4，第一轮排序根据最末位放在数组的下标4处，第二轮排序根据倒数第二位放在数组的下标3处，然后遍历数组即可。

## 桶排序

![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1gczkdcq6txj30t10s6k2y.jpg)

![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1gczkdu2j6yj30t40mxwo8.jpg)

- 时间复杂度：遍历数组求最大值最小值为O(n)，遍历数组放入"桶"中复杂度为O(n)，遍历桶取出每个值的复杂度为O(n)，最终的时间复杂度为O(3n)，也就是O(n)

- 空间复杂度：额外的空间取决于元素的取值范围，总的来说为O(n)

- 稳定性：桶排序是否稳定取决于"桶"用什么数据结构实现，如果是队列，那么可以保证相同的元素"取出去"后的相对位置与"放进来"之前是相同的，即排序是稳定的，而如果用栈来实现"桶"，则排序一定是不稳定的，因为桶排序可以做到稳定，所以桶排序是稳定的排序算法

**参考**：

- [排序算法总结](https://www.runoob.com/w3cnote/sort-algorithm-summary.html)

- [[图解] 桶排序](https://www.jianshu.com/p/63db6903c32a)

## 稳定性

1. 堆排序、快速排序、希尔排序、直接选择排序**不是稳定**的排序算法；

2. 基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序**是稳定**的排序算法。

**参考**：

- [八大排序算法稳定性分析，原来稳定性是这个意思...](https://zhuanlan.zhihu.com/p/36120420)

- [常见排序算法的最好、最坏、平均时间复杂度以及空间复杂度](https://blog.csdn.net/Big_Rotor/article/details/97971263)

---
