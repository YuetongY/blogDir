[toc]

# 树和二叉树

## 深度和高度

![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1gck0qzmswej30bx07emxl.jpg)

- 深度：某节点离根节点的距离+1

    该树的深度为3；节点1的深度为1；节点2的深度为2；节点4的深度为3

- 高度：某节点离当前节点的所在子树中叶子节点的最大的距离

    该树的高度为3；节点1的高度为3；节点2的高度为2；节点4的高度为1

---

## 树

树是由结点或顶点和边组成的(可能是非线性的)且不存在着任何环的一种数据结构。没有结点的树称为空(null或empty)树。一棵非空的树包括一个根结点，还(很可能)有多个附加结点，所有结点构成一个多级分层结构。

![image.png](https://ww1.sinaimg.cn/large/006alGmrly1g9gccegglqj309a06z74g.jpg)

![image.png](https://ww1.sinaimg.cn/large/006alGmrly1g9gcdjx5lpj30r20ox427.jpg)

---

## 树的存储结构

### 1. 双亲表示法

由于树中的每个结点都有唯一的一个双亲结点，所以用一组连续的存储空间（一维数组）存储树中的各个结点，一个数组元素表示树的一个结点，每个结点含两个域，数据域存放结点本身信息，双亲域指示本结点的双亲结点在数组中位置。

### 2. 孩子表示法

树中的每个结点可能有多棵子树，则可用多重链表表示，即每个结点有多个指针域，其中每个指针域指向一棵子树的根结点。这样的话，会存在两种结点格式。

![image.png](http://ww1.sinaimg.cn/large/007UI2RRgy1g9xl6t0dj1j30lr03vdgm.jpg)

1. 第一种结点格式结点是同构的，d为树的度（分支数目）。因为大多数的结点的度都小于d，则会有很多空链域。n个结点度为k的树中必有n(k-1)+1个空链域。

2. 第二种结点格式不是同构的，d为结点度，degree域的值同d，节约空间，但操作不方便。

两种格式的区别在于：第一种格式是默认以树的度为d的值。 而第二种格式是以结点的度为d的值，也就是degree的值。

**另一种孩子表示法**：每个结点的孩子结点排列起来，成一个线性表，以单链表作存储结构。n个结点有n个孩子链表（叶子的孩子链表为空表）。最后n个头指针又组成一个线性表。

孩子表示法与孩子双亲表示法，如下图：

![image.png](http://ww1.sinaimg.cn/large/007UI2RRgy1g9xld2eundj30nc07ngoh.jpg)

### 3. 兄弟表示法

孩子兄弟表示法（==二叉链表==表示法）：在存储结点信息的同时，附加两个分别指向该结点最左孩子和右邻兄弟的指针域fch和nsib，即可得树的孩子兄弟链表表示。

![image.png](http://ww1.sinaimg.cn/large/007UI2RRgy1g9xled9w0sj30my0bv41p.jpg)

**参考**：[树与森林](https://www.jianshu.com/p/e88389362af8)

---

## 二叉树

每个结点至多拥有两棵子树(即二叉树中不存在度大于2的结点)，并且，二叉树的子树有左右之分，其次序不能任意颠倒。

**性质**：

1. 若二叉树的层次从0开始，则在二叉树的第i层至多有2^i个结点(i>=0)。

2. 高度为k的二叉树最多有2^(k+1) - 1个结点(k>=-1)。 (空树的高度为-1)

3. 对任何一棵二叉树，如果其叶子结点(度为0)数为m, 度为2的结点数为n, 则m = n + 1。

**完美二叉树**：

![image.png](https://ww1.sinaimg.cn/large/006alGmrly1g9gcf699q4j30oc08jt9z.jpg)

**完全二叉树**：

![image.png](https://ww1.sinaimg.cn/large/006alGmrly1g9gcfqf0ivj30mv08raaa.jpg)

**完满二叉树(Full Binary Tree)**：

![image.png](https://ww1.sinaimg.cn/large/006alGmrly1g9gcgeyc2jj30hc09rdg3.jpg)

**平衡（AVL）二叉树**：

**平衡二叉树一定是二叉排序树**。

- 它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。

- 若将二叉树节点的平衡因子BF定义为该节点的左子树的深度减去它的右子树的深度，则平衡二叉树上所有节点的平衡因子只可能为-1,0,1.

- 只要二叉树上有一个节点的平衡因子的绝对值大于1，那么这颗平衡二叉树就失去了平衡。

![image.png](https://ww1.sinaimg.cn/large/006alGmrly1g9jqwvlgyxj30hr0ehju5.jpg)

总结一下二叉排序树的不平衡情况以及如何将其转化为平衡情况。
一般情况下，假设由于在二叉排序树上插入结点而失去平衡的最小子树根结点的指针为a（即a是离插入结点最近，且平衡因子绝对值不超过1的祖先结点），则失去平衡后进行调整的规律可以归纳为一下4种情况：

![image.png](https://ww1.sinaimg.cn/large/006alGmrly1g9jr2eh05fj30kt0e00w0.jpg)

**应用场景**：二叉搜索树。插入和删除运算中，采用平衡树的长处是：使树的结构较好，从而提高查找运算的速度。缺点是：是插入和删除运算变得复杂化，从而减少了他们的运算速度。对二叉搜索树删除节点而引起的不平衡性进行的操作比插入节点的情况要复杂，在此就不再论述了。

**参考**：

- [完美二叉树, 完全二叉树和完满二叉树](https://blog.csdn.net/qq_22642239/article/details/80774013)

- [平衡二叉树及其应用场景](https://www.cnblogs.com/blfshiye/p/4033094.html)

---

## 二叉搜索树

1.所有非叶子结点至多拥有两个儿子（Left和Right）；

2.所有结点存储一个关键字；

3.非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；

![image.png](https://ww1.sinaimg.cn/large/006alGmrly1g9jn6m35r5j307507egmu.jpg)

二叉搜索树的搜索，从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；否则，如果查询关键字比结点关键字小，就进入左儿子；如果比结点关键字大，就进入右儿子；如果左儿子或右儿子的指针为空，则报告找不到相应的关键字；

==如果二叉搜索树的所有非叶子结点的左右子树的结点数目均保持差不多（平衡），那么B树的搜索性能逼近二分查找；但它比连续内存空间的二分查找的优点是，改变二叉搜索树结构（插入与删除结点）不需要移动大段的内存数据，甚至通常是常数开销；==

![image.png](https://ww1.sinaimg.cn/large/006alGmrly1g9jn8q8mvrj30f209ggoa.jpg)

但二叉搜索树在经过多次插入与删除后，有可能导致不同的结构：

![image.png](https://ww1.sinaimg.cn/large/006alGmrly1g9jn96y7waj30du079768.jpg)

右边也是一个二叉搜索树，但它的==搜索性能已经是线性的了==；==同样的关键字集合有可能导致不同的树结构索引==；所以，==使用二叉搜索树还要考虑尽可能让B树保持左图的结构，和避免右图的结构，也就是所谓的“平衡”问题；==

==实际使用的二叉搜索树都是在原二叉搜索树的基础上加上平衡算法，即“平衡二叉树”；如何保持B树结点分布均匀的平衡算法是平衡二叉树的关键；平衡算法是一种在二叉搜索树中插入和删除结点的策略；==

### B树（B-树）

B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者B树和B+树的数据结构

**规则**：

![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1gcqbqhabpbj31170il7i3.jpg)

![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1g9jrylzaaqj30hd07qtbq.jpg)

**在B-树叶结点上删除一个关键字的方法是**：（参考题目：[https://www.nowcoder.com/test/question/done?tid=31121099&qid=52331#summary](https://www.nowcoder.com/test/question/done?tid=31121099&qid=52331#summary)）

首先将要删除的关键字 k直接从该叶子结点中删除。然后根据不同情况分别作相应的处理，共有三种可能情况：

（1）如果被删关键字所在结点的原关键字个数n>=ceil(m/2)（即上取整），说明删去该关键字后该结点仍满足B-树的定义。这种情最为简单，只需从该结点中直接删去关键字即可。

（2）如果被删关键字所在结点的关键字个数n等于ceil(m/2)-1，说明删去该关键字后该结点将不满足B-树的定义，需要调整。

调整过程为：如果其左右兄弟结点中有“多余”的关键字,即与该结点相邻的右（左）兄弟结点中的关键字数目大于ceil(m/2)-1。则可将右（左）兄弟结点中最小（大）关键字上移至双亲结点。而将双亲结点中小（大）于该上移关键字的关键字下移至被删关键字所在结点中。

### B+树

B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。

（1）B+跟B树不同B+树的非叶子节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个非叶子节点所能保存的关键字大大增加；

（2）B+树叶子节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；

（3）B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。

（4）有 n 棵子树的结点中包含有 n 个关键字；

![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1g9jsbjzid0j30g509zn2d.jpg)

**特点**：

1、B+树的层级更少：相较于B树，B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；

2、B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;

3、B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。

4、B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。

==B树相对于B+树的优点==是，如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快。

### B*树

是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针

![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1g9jsjp753aj30g909sgr2.jpg)

B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）；

B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；

B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；

==所以，B*树分配新结点的概率比B+树要低，空间使用率更高==

**小结**：

1. B（B-）树：多路搜索树，每个结点存储M/2-1（去上整）到M-1个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；

2. B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；

3. B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3

**参考**：

- [平衡二叉树、B树、B+树、B*树 理解其中一种你就都明白了](https://zhuanlan.zhihu.com/p/27700617)

- [B树、B-树、B+树、B*树](https://blog.csdn.net/qq_28584889/article/details/88777393)

---

## 线索二叉树

通过考察各种二叉链表，不管儿叉树的形态如何，空链域的个数总是多过非空链域的个数。准确的说，n各结点的二叉链表共有2n个链域，非空链域为n-1个，但其中的空链域却有n+1个。如下图所示。

![image.png](http://ww1.sinaimg.cn/large/006alGmrgy1g9kp306q34j30bn05m752.jpg)

因此，提出了一种方法，利用原来的空链域存放指针，指向树中其他结点。这种指针称为线索。

记ptr指向二叉链表中的一个结点，以下是建立线索的规则：

    （1）如果ptr->lchild为空，则存放指向中序遍历序列中该结点的前驱点。这个结点称为ptr的中序前驱；
    （2）如果ptr->rchild为空，则存放指向中序遍历序列中该结点的后继点。这个结点称为ptr的中序后继；

显然，在决定lchild是指向左孩子还是前驱，rchild是指向右孩子还是继，需要一个区分标志的。因此，我们在每个结点再增设两个标志域ltagrtag，注意ltag和rtag只是区分0或1数字的布尔型变量，其占用内存空要小于像lchild和rchild的指针变量。结点结构如下所示。

![image.png](http://ww1.sinaimg.cn/large/006alGmrgy1g9kp3mfhcsj30ak01dweh.jpg)

其中：

    （1）ltag为0时指向该结点的左孩子，为1时指向该结点的前驱；

    （2）rtag为0时指向该结点的右孩子，为1时指向该结点的后继；

    （3）因此对于上图的二叉链表图可以修改为下图的养子。

![image.png](http://ww1.sinaimg.cn/large/006alGmrgy1g9kp44nwttj30fm068aay.jpg)

**参考**：[彻底理解线索二叉树](https://www.cnblogs.com/guweiwei/p/7090050.html)

---

## 赫夫曼树

![image.png](https://ww1.sinaimg.cn/large/006alGmrly1g9lj5fenukj307h079mx6.jpg)

- 路径
    路径是指在一棵树中，从一个节点到另一个节点之间的分支构成的通路，如从节点8到节点1的路径如图所示

- 路径长度
    路径长度指的是路径上边的数目，在上图中，路径长度为2。

- 节点的权
    节点的权指的是为树中的每一个节点赋予的一个非负的值，如上图中每一个节点中的值。

- 节点的带权路径长度
    节点的带权路径长度指的是从根节点到该节点之间的路径长度与该节点权的乘积：如对于1节点的带权路径长度为：2。

- 树的带权路径长度
树的带权路径长度指的是所有叶子节点的带权路径长度之和。

**有了如上的概念，对于Huffman树，其定义为**：
    给定nn权值作为nn个叶子节点，构造一棵二叉树，若这棵二叉树的带权路径长度达到最小，则称这样的二叉树为最优二叉树，也称为Huffman树。

由以上的定义可以知道，Huffman树是带权路径长度最小的二叉树，对于上面的二叉树，其构造完成的Huffman树为：

![image.png](https://ww1.sinaimg.cn/large/006alGmrly1g9lj6zlbjej30c507yweq.jpg)

**huffman 树的构建**：

由上述的Huffman树可知：节点的权越小，其离树的根节点越远。那么应该如何构建Huffman树呢？以报文“AFTERDATAEARAREARTAREA”为例，首先需要统计出每个字符出现的次数作为节点的权:

![image.png](https://ww1.sinaimg.cn/large/006alGmrly1g9lj8jiotaj302t038q2t.jpg)

接下来构建Huffman树：

- 重复以下的步骤：
    - 按照权值对每一个节点排序：D-F-T-E-R-A
    - 选择权值最小的两个节点，此处为D和F生成新的节点，节点的权重为这两个节点的权重之和，为2
- 直到只剩最后的根节点

按照上述的步骤，该报文的Huffman树的生成过程为：

![image.png](https://ww1.sinaimg.cn/large/006alGmrly1g9ljahk1coj30dl0ihq46.jpg)

**由Huffman树生成Huffman编码**：

有了上述的Huffman树的结构，现在我们需要利用Huffman树对每一个字符编码，该编码又称为Huffman编码，Huffman编码是一种前缀编码，即一个字符的编码不是另一个字符编码的前缀。在这里约定：

- 将权值小的最为左节点，权值大的作为右节点

- 左孩子编码为0，右孩子编码为1

因此，上述的编码形式如下图所示：

![image.png](https://ww1.sinaimg.cn/large/006alGmrly1g9ljbkl1n9j30a908bq35.jpg)

**参考**：

- [数据结构和算法——Huffman树和Huffman编码](https://blog.csdn.net/google19890102/article/details/54848262s)

- [赫夫曼树及其应用](https://www.cnblogs.com/zhuyf87/archive/2012/11/06/2756265.html)

---

## 红黑树

红黑树是一种自平衡的**二叉查找树**。它可以在O(log n)时间复杂度内实现查找，插入和删除，任何不平衡都会在三次旋转内解决。构建一颗二叉树的时间复杂度为O(log n)。

具有如下特性：

1.节点是红色或黑色。

2.根节点是黑色。

3.每个叶子节点都是黑色的空节点（NIL节点）。

4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)

5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

**应用场景**：

红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况。在数据较小，可以完全放到内存中时，微软STL的map和set的内部实现就是红黑树。红黑树的时间复杂度比B树低。

**参考**：

- [漫画算法：什么是红黑树？（适合初学红黑树小白简单易懂）](https://blog.csdn.net/chudelong1/article/details/82698010)

- [B树，B+树，红黑树应用场景笔记](https://blog.csdn.net/qq_36183935/article/details/81095212)

- [深入理解红黑树与B+树应用场景](https://blog.csdn.net/yu876876/article/details/82892112?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)

---

## 前缀树/字典树

![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1gbsb7sv303j30mq0kn77b.jpg)

Trie又被称为前缀树、字典树，所以当然是一棵树。上面这棵Trie树包含的字符串集合是{in, inn, int, tea, ten, to}。每个节点的编号是我们为了描述方便加上去的。树中的每一条边上都标识有一个字符。这些字符可以是任意一个字符集中的字符。比如对于都是小写字母的字符串，字符集就是’a’-‘z’；对于都是数字的字符串，字符集就是’0’-‘9’；对于二进制字符串，字符集就是0和1。

比如上图中3号节点对应的路径0123上的字符串是inn，8号节点对应的路径0568上的字符串是ten。终结点与集合中的字符串是一一对应的。

### 原理

参考链接

### 数据结构和代码实现

一个二维数据存储节点

具体参考链接

### 应用场景

- 字符串检索

- 词频统计

- 排序

- 字符串最长公共前缀

- 字符串搜索的前缀匹配

具体参考第二个链接

**参考**：

- [字典树(前缀树)](https://blog.csdn.net/weixin_39778570/article/details/81990417)

- [Trie（前缀树/字典树）及其应用](https://www.cnblogs.com/bonelee/p/8830825.html)

- [go 语言实现](https://blog.csdn.net/idwtwt/article/details/88193548)

---
