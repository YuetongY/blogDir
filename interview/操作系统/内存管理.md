[toc]

# 内存管理

**直接看最后的链接参考更清晰一些**。

## 内存的连续分配

### 单一连续分配方式

内存在此方式下分为**系统区**和**用户区**

系统区仅提供给操作系统使用，通常在低地址部分

用户区是为用户提供的、除系统区之外的内存空间

**优点**：简单、无外部碎片，可以釆用覆盖技术，不需要额外的技术支持

**缺点**：只能用于单用户、单任务的操作系统中，有内部碎片，存储器的利用率极低

### 固定分区分配

固定分区分配是最简单的一种多道程序存储管理方式。

**将用户内存空间划分为若干个固定大小的区域，每个分区只装入一道作业。**

当有空闲分区时，便可以再从外存的后备作业队列中,选择适当大小的作业装入该分区，如此循环。

**划分分区方法**：

1. 分区大小相等

2. 分区大小不等

**存在的问题**：

- 程序可能太大而放不进任何一个分区中，这时用户不得不使用覆盖技术来使用内存空间

- 主存利用率低，当程序小于固定分区大小时，也占用了一个完整的内存分区空间，产生内部碎片

### 动态分区分配

又称为可变分区分配，这种分区方法不预先将内存划分，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统中分区的大小和数目是可变的。

**动态分区分配算法**：

- 首次适应(First Fit)算法：空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。

- 最佳适应(Best Fit)算法：空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区。

- 最坏适应(Worst Fit)算法：又称最大适应(Largest Fit)算法，空闲分区以容量递减的次序链接。找到第一个能满足要求的空闲分区，也就是挑选出最大的分区。

- 临近适应算法(Next fit)算法：从当前位置开始，搜索第一个能满足进程要求的内存空间

**动态分区的缺点**：

随着时间的推移，内存中会产生越来越多的外部碎片，内存的利用率随之下降。

---

## 内存的非连续分配

### 页式存储

#### 基本概念

**基本思想**：用户程序的地址空间被划分成若干固定大小的区域，称为“页”，相应地，内存空间分成若干个物理块或页帧（Page Frame），页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配：物理块不一定连续。每个页对应一个物理块。

**逻辑地址结构**：地址结构包含两部分：前一部分为页号P，后一部分为页内偏移量W。如果是32位地址，则0~11位为页内地址，即每页大小为4KB；12~31位为页号，地址空间最多允许有页

**页表**：因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，因此需要一个页表来记录逻辑地址和实际存储地址之间的映射关系，以实现从页号到物理块号的映射

#### 地址变换

地址变换的任务是将逻辑地址转换为内存中物理地址，地址变换是借助于页表实现的

当进程执行时，将页表始址和长度存入页表寄存器

设页大小为L（一般为4K），逻辑地址A到物理地址E的变换过程如下：

- 计算页号P(P=A/L)和页内偏移量W (W=A%L)，这里的P取整

- 比较页号P和页表长度M，若P >= M，则产生越界中断，否则继续执行

- 页表中页号P对应的页表项地址 = 页表起始地址F + 页号P * 页表项长度（一般为4B），取出该页表项内容b，即为物理块号

- 计算E=b*L+W，用得到的物理地址E去访问内存

#### 分页管理方式存在的问题

- 每次访存操作都需要进行逻辑地址到物理地址的转换，地址转换过程必须足够快，否则访存速度会降低

- 每个进程引入了页表，用于存储映射机制，页表不能太大，否则内存利用率会降低

#### 具有快表的地址变换机构

#### 二级页表

### 段式存储

>分页是为了提高内存利用率，提升计算机的性能, 且分页通过硬件机制实现，对用户完全透明
而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。

**基本思想**：将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息，每个段内部从0开始编址。存储分配时，以段为单位，每个段内部连续分配内存，段与段在内存中可以不相邻接，也实现了离散分配。例如，用户进程由主程序、两个子程序、栈和一段数据组成，于是可以把这个用户进程划分为5个段。

**逻辑地址结构**：段号S与段内偏移量W两部分组成。如果是32位地址，段号为16位，段内偏移量为16位，则一个作业最多可有=65536个段，最大段长为65536B即64KB

>页式系统中，逻辑地址的页号和页内偏移量对用户是透明的，但在段式系统中，段号和段内偏移量必须由用户显示提供，在髙级程序设计语言中，这个工作由编译程序完成

**段表**：每个进程都有一张逻辑空间与内存空间映射的段表，其中每一个段表项对应进程的一个段。

访问内存的时候根据段号和段表项的长度计算当前访问段在段表中的位置，然后访问段表，得到该段的物理地址，根据该物理地址以及段内偏移量就可以得到需要访问的内存。

#### 地址变换

为了实现进程从逻辑地址到物理地址的变换功能，在系统中设置了段表寄存器

1. 段表寄存器存了段表始址F和段表长度M，从逻辑地址A到物理地址E之间的地址变换过程如下：

2. 从逻辑地址A中取出前几位为段号S，后几位为段内偏移量W
比较段号S和段表长度M，若S多M，则产生越界中断，否则继续执行

3. 段表中段号S对应的段表项地址 = 段表起始地址F + 段号S * 段表项长度，取出该段表项的前几位得到段长C。若段内偏移量>=C，则产生越界中断，否则继续执行

4. 取出段表项中该段的起始地址b，计算 E = b + W，用得到的物理地址E去访问内存

#### 段的共享

段的共享是通过两个作业的段表中相应表项指向被共享的段的同一个物理副本来实现的

不能修改的代码称为纯代码或可重入代码（它不属于临界资源)，这样的代码和不能修改的数据是可以共享的

而可修改的代码和数据则不能共享

### 分页与分段的区别

**段式管理**：

- 优点：没有内部碎片（因为段大小可变，改变段大小来消除内碎片）。

- 缺点：段换入换出时，会产生外部碎片（比如4k的段换5k的段，会产生1k的外碎片）

**页式管理**：

- 优点：没有外部碎片（因为页的大小固定），

- 缺点：会产生内部碎片（一个页可能填充不满）

**分页与分段的区别**：

- 目的不同：分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位；分段的目的是为了能更好地满足用户的需要，它是信息的逻辑单位，它含有一组其意义相对完整的信息；

- 大小不同：页的大小固定且由系统决定（一般为4k），而段的长度却不固定，由其所完成的功能决定；

- 地址空间不同： 段向用户提供二维地址空间；页向用户提供的是一维地址空间；一个段在物理空间是连续的内存。

- 信息共享：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制；

- 内存碎片：页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。

### 段页式存储

页式存储管理能有效地提高内存利用率，而分段存储管理能反映程序的逻辑结构并有利于段的共享。

如果将这两种存储管理方法结合起来，就形成了段页式存储管理方式

#### 基本概念

**基本思想**：

- 作业的地址空间首先被分成若干个逻辑段，每段都有自己的段号

- 再将每一段分成若干个大小固定的页

- 对内存空间的管理仍然和分页存储管理一样，将其分成若干个和页面大小相同的块，对内存的分配以块为单位

逻辑地址结构：段号S、页号P和页内偏移量W。

每个进程建立一张段表，而每个分段有一张页表

#### 地址变换

为了实现进程从逻辑地址到物理地址的变换功能，在系统中设置了段表寄存器

进行一次访问实际需要三次访问内存

1. 首先利用段号S，将它与段表长TL进行比较。若S<TL，表示未越界

2. 根据段表始址F和段号S来求出该段所对应的段表项在段表中的位置，从中得到该段的页表始址

3. 根据段内页号P来获得对应页的页表项位置，从中读出该页所在的物理块号b

4. 利用块号b和页内地址来构成物理地址

---

## 虚拟内存

虚拟内存的基本思想是：在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存,然后继续执行程序。

虚拟内存容量：内存+外存

理论依据：局部性原理

与传统存储器比较虚拟存储器有以下三个主要特征：

- 多次性，是指无需在作业运行时一次性地全部装入内存，而是允许被分成多次调入内存运行。

- 对换性，是指无需在作业运行时一直常驻内存，而是允许在作业的运行过程中，进行换进和换出。

- 虚拟性，是指从逻辑上扩充内存的容量，使用户所看到的内存容量，远大于实际的内存容量。

虚拟内存的实现有以下两种方式：

- 请求分页存储管理

- 请求分段存储管理

- 请求段页式存储管理

### 请求分页存储管理

将当前需要的一部分页面装入内存，便可以启动作业运行。在作业执行过程中，当所要访问的页面不在内存时，再通过调页功能将其调入，同时还可以通过置换功能将暂时不用的页面换出到外存上，以便腾出内存空间

#### 地址变换

请求分页系统中的地址变换机构，是在分页系统地址变换机构的基础上，为实现虚拟内存，又增加了某些功能而形成的

请求分页系统中，每当所要访问的页面不在内存时，便产生一个缺页中断，请求操作系统将所缺的页调入内存

**缺页中断处理中**：

- 如果内存中有空闲块，则分配一个块，将要调入的页装入该块

- 若此时内存中没有空闲块，则要淘汰某页

- 若被淘汰页在内存期间被修改过，则要将其写回外存

#### 页面置换算法

进程运行时，若其访问的页面不在内存而需将其调入，但内存已无空闲空间时，就需要从内存中调出一页程序或数据，送入磁盘的对换区。

选择调出页面的算法就称为页面置换算法

- 最优页面置换算法

- 先进先出页面置换算法（FIFO）

- 最近最久未使用页面置换算法LRU（Least Recently Used）

- 时钟置换算法(Clock Page Replacement Algorithm)

#### 页面抖动（ 颠簸）

颠簸本质上是指频繁的页面调度行为，具体来讲，进程发生缺页中断，这时，必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此，会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸（抖动）

**内存颠簸的解决策略包括**：

如果是因为页面替换策略失误，可以修改替换算法来解决这个问题；

如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量；

终止该进程或增加物理内存容量。

#### 驻留集大小

驻留集：对于分页式的虚拟内存，不需要把一个进程的所有页都读取到主存，操作系统必须决定读取多少页。也就是说，给特定的进程分配多大的主存空间，这就是驻留集。

#### 调入页面的时机

为确定系统将进程运行时所缺的页面调入内存的时机，可釆取以下两种调页策略

#### 从何处调入页面

请求分页系统中的外存分为两部分：

- 用于存放文件的文件区，釆用连续分配方式

- 用于存放对换页面的对换区，釆用离散分配方式

**参考**：[操作系统面试：内存管理](https://blog.csdn.net/ChaunceyChen/article/details/86672415)

---
