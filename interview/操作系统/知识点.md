# 知识点

## 进程，线程和协程的区别

`进程`：是 “程序执行的一个实例” ，是系统分配资源的实体。进程创建必须分配一个完整的独立地址空间。至少有 5 种基本状态，它们是：初始态，执行态，等待状态，就绪状态，终止状态。

`线程`：是进程的一个执行流，独立执行它自己的程序代码。是操作系统能够进行运算调度的最小单位。.可与同属一个进程的其他的线程共享进程所拥有的全部资源。

**进程和线程的区别**：

1. 拥有资源

    进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。

2. 调度

    线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

3. 系统开销

    由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

4. 通信方面

    线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

`协程`：是轻量级的线程，一个进程可轻松创建数十万计的协程。协程的调度完全由用户控制。

`线程和协程的区别`：

1. 一个线程可以多个协程，一个进程也可以单独拥有多个协程

2. 最大的优势就是协程极高的执行效率。协程切换的开销小于线程切换。

**参考**：

- [每个程序员都会遇到的面试问题：谈谈进程和线程的区别](https://www.cnblogs.com/jobbible/p/9766649.html)

- [【linux操作系统】进程和线程](https://blog.csdn.net/xing1584114471/article/details/92793556)

- [协程与线程的区别](https://blog.csdn.net/fadbgfnbxb/article/details/88787361)

- [https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.md](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.md)

- [协程](https://www.liaoxuefeng.com/wiki/897692888725344/923057403198272)

---

## 内核态和用户态

操作系统的两种不同 cpu 状态

- 内核态（Kernel Mode）：运行操作系统程序，操作硬件

- 用户态（User Mode）：运行用户程序

**内核态与用户态的区别**：

- 内核态与用户态是操作系统的两种运行级别，当程序运行在3级特权级上时，就可以称之为运行在用户态。因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；当程序运行在0级特权级上时，就可以称之为运行在内核态。

- 运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态（比如操作硬件）。

- 处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的；处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。

**参考**：[用户态和内核态的区别](https://www.cnblogs.com/gizing/p/10925286.html)

---

## 进程生命周期，五种基本状态

![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1gcd4wnu75kj30n80cx41k.jpg)

- 创建状态：进程在创建时需要申请一个空白PCB，向其中填写控制和管理进程的信息，完成资源分配。如果创建工作无法完成，比如资源无法满足，就无法被调度运行，把此时进程所处状态称为创建状态

- 就绪状态：进程已经准备好，已分配到所需资源，只要分配到CPU就能够立即运行

- 执行状态：进程处于就绪状态被调度后，进程进入执行状态

- 阻塞状态：正在执行的进程由于某些事件（I/O请求，申请缓存区失败）而暂时无法运行，进程受到阻塞。在满足请求时进入就绪状态等待系统调用

- 终止状态：进程结束，或出现错误，或被系统终止，进入终止状态。无法再执行

**参考**：[进程的五种基本状态 - 操作系统](https://blog.csdn.net/cafucwxy/article/details/78453430)

---

## 单工，半双工和全双工

![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1gcde6heqdzj30ku06o107.jpg)

**参考**：[单工，半双工和全双工有何区别和联系？](https://zhidao.baidu.com/question/58243700.html)

---

## 进程同步

1. 临界区

2. 信号量

3. 管程

**参考**：[https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.md](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.md)

---

## 经典同步问题

1. 哲学家进餐问题

2. 读者-写者问题

3. 生产者-消费者问题

**参考**：[https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.md](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.md)

---

## 进程通信

1. 管道

    - 只支持半双工通信（单向交替传输）；

    - 只能在父子进程或者兄弟进程中使用。

2. FIFO

    也称为命名管道，去除了管道只能在父子进程中使用的限制。

    FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。

3. 消息队列

4. 信号量

    它是一个计数器，用于为多个进程提供对共享数据对象的访问

5. 共享存储

    允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。

    需要使用信号量用来同步对共享存储的访问。

6. 套接字

    与其它通信机制不同的是，它可用于不同机器间的进程通信。

**参考**：[https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.md](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.md)

---

## 负载均衡

负载均衡器会根据集群中每个节点的负载情况，将用户请求转发到合适的节点上。

**负载均衡算法**：

- 轮询（Round Robin）

- 加权轮询（Weighted Round Robbin）

- 最少连接（least Connections）

- 加权最少连接（Weighted Least Connection）

- 随机算法（Random）

- 源地址哈希法 (IP Hash)

---

## 程序运行时内存分配的三种方式

- 静态存储区

- 栈区

- 堆区

**参考**：

- [https://blog.csdn.net/qq_35422344/article/details/88093021](https://blog.csdn.net/qq_35422344/article/details/88093021)

- [内存空间分配某面试题](https://blog.csdn.net/weixin_37389821/article/details/83479241)

---

## 堆栈的区别

![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1gckbgg3tb4j30pa0h1gp9.jpg)

1.栈内存存储的是局部变量而堆内存存储的是实体；

2.栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；

3.栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。

**参考**：[Java中堆和栈有什么区别](https://www.php.cn/faq/416802.html)

---
