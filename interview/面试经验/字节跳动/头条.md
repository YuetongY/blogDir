# 头条

- **进程和线程以及它们之间的区别**：

    `进程`：是 “程序执行的一个实例” ，是系统分配资源的实体。进程创建必须分配一个完整的独立地址空间。至少有 5 种基本状态，它们是：初始态，执行态，等待状态，就绪状态，终止状态。

    `线程`：是进程的一个执行流，独立执行它自己的程序代码。是操作系统能够进行运算调度的最小单位。.可与同属一个进程的其他的线程共享进程所拥有的全部资源。

    **进程和线程的区别**：

    1. 资源分配&处理器调度：进程是资源分配的基本单位，线程是处理器调度的基本单位

    2. 地址空间：进程拥有独立的地址空间；线程没有独立的地址空间，同一进程内多个线程共享其资源;

    3. 一个进程可以有多个线程，但至少有一个线程；而一个线程只能在一个进程的地址空间内活动。

    4. 资源分配给进程，同一进程的所有线程共享该进程的所有资源。 同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。

    5. 处理机分给线程，即真正在处理机上运行的是线程。

    6. 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。

    `协程`：是轻量级的线程，一个进程可轻松创建数十万计的协程。协程的调度完全由用户控制。

    `线程和协程的区别`：

    1. 一个线程可以多个协程，一个进程也可以单独拥有多个协程

    2. 线程是抢占式，而协程是非抢占式的，所以需要用户自己释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。

    **参考**：

    - [每个程序员都会遇到的面试问题：谈谈进程和线程的区别](https://www.cnblogs.com/jobbible/p/9766649.html)

    - [【linux操作系统】进程和线程](https://blog.csdn.net/xing1584114471/article/details/92793556)

    - [协程与线程的区别](https://blog.csdn.net/fadbgfnbxb/article/details/88787361)

    ---

- **cookie 和 session 的区别**：

    1. 存储位置不同：cookie 存放在客户端浏览器上，session 存放在服务器中

    2. 存储容量不同：单个 cookie 保存的数据 <=4k，一个站点最多保存 20 个cookie。session 理论上没有限制，不过为了服务器性能，session 内不要放置过多的东西，且设置 session 删除机制。

    3. 隐私策略不同：cookie 对客户端可见，其它人可以分析存放在本地的 cookie 进行 cookie 欺骗。所以它不安全。session 对客户端是透明的，不存在敏感数据泄露的风险。

    4. 服务器压力不同：cookie 保存在客户端，不会给服务器造成压力；session 保存在服务端，每个用户都会产生一个 session，耗费大量内存。

    5. 跨域支持不同：cookie 支持跨域访问；session 不支持跨域访问。

    **参考**：[Cookie和Session的区别](https://www.jianshu.com/p/2f7031a69f43)

- **死锁的四个必要条件**：

    - 互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。

    - 请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。

    - 不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。

    - 循环等待条件: 若干进程间形成首尾相接循环等待资源的关系

    这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。

- **RPC 原理和框架**：

    RPC 的全称是 Remote Procedure Call 是一种进程间通信方式。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即无论是调用本地接口/服务的还是远程的接口/服务，本质上编写的调用代码基本相同。

    ![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1gc3uryvkkaj30m30hy43f.jpg)

    **参考**：[RPC原理及实现](https://www.cnblogs.com/twinhead/p/9900605.html)

- **如果在某一时刻有大量的缓存失效，有大量的请求落到数据库上，怎么处理**：

    **参考**：[缓存穿透、缓存击穿和缓存雪崩实践 侵删](https://blog.csdn.net/qq_22167989/article/details/100860288)

- **讲一下分布式锁，如何实现**：

    分布式锁是控制分布式系统或不同系统之间共同访问共享资源的一种锁实现，如果不同的系统或同一个系统的不同主机之间共享了某个资源时，往往需要互斥来防止彼此干扰来保证一致性。

    **参考**：

    1. [分布式锁](https://blog.csdn.net/zhouwei1221q/article/details/71457006)

    2. [三种实现分布式锁的方式](https://blog.csdn.net/wuzhiwei549/article/details/80692278)

- **更新数据的时候是先更新redis还是mysql**：

    先更新DB再删除缓存（使用场景多）

    **参考**：[更新数据时，是先删除缓存再更新DB，还是先更新DB再删除缓存？](https://blog.csdn.net/wangxin1982314/article/details/89317465)

- **介绍一下垃圾回收机制及垃圾回收算法**:

    垃圾回收机制专门用来回收不可用的变量值所占用的内存空间

    1. 引用计数

    2. 标记-清除

    3. 分代收集

    **参考**：
    
    1. [垃圾回收机制](https://www.cnblogs.com/12345huangchun/p/10217342.html)

    2. [GO语言垃圾回收机制](https://studygolang.com/articles/25096?fr=sidebar)

- **面向对象的特性**：

    1. 对象唯一性

    2. 抽象性

    3. 继承性

    4. 多态性

    **参考**：[面向对象特性]

- **操作系统中进程调度策略**：

    1. FCFS(先来先服务)

    2. 优先级

    3. 时间片轮转

    4. 多级反馈-调度算法

    **参考**：[操作系统中进程调度策略有哪几种？](https://www.cnblogs.com/hjh-666/p/11449470.html)

- linux 中如何创建进程

    在Linux系统中，除了系统启动之后的第一个进程由系统来创建，其余的进程都必须由已存在的进程来创建，新创建的进程叫做子进程，而创建子进程的进程叫做父进程。那个在系统启动及完成初始化之后，Linux自动创建的进程叫做根进程。根进程是Linux中所有进程的祖宗，其余进程都是根进程的子孙。具有同一个父进程的进程叫做兄弟进程。

    在Linux中，父进程以分裂的方式来创建子进程，创建一个子进程的系统调用叫做fork()。

    ![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1gc9josr63zj30fm080wg5.jpg)

    **参考**：[【Linux】Linux进程的创建与管理](https://blog.csdn.net/qq_38410730/article/details/81193118)