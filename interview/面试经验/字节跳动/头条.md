# 头条

- **进程和线程以及它们之间的区别**：

    `进程`：是 “程序执行的一个实例” ，是系统分配资源的实体。进程创建必须分配一个完整的独立地址空间。至少有 5 种基本状态，它们是：初始态，执行态，等待状态，就绪状态，终止状态。

    `线程`：是进程的一个执行流，独立执行它自己的程序代码。是操作系统能够进行运算调度的最小单位。.可与同属一个进程的其他的线程共享进程所拥有的全部资源。

    **进程和线程的区别**：

    1. 资源分配&处理器调度：进程是资源分配的基本单位，线程是处理器调度的基本单位

    2. 地址空间：进程拥有独立的地址空间；线程没有独立的地址空间，同一进程内多个线程共享其资源;

    3. 一个进程可以有多个线程，但至少有一个线程；而一个线程只能在一个进程的地址空间内活动。

    4. 资源分配给进程，同一进程的所有线程共享该进程的所有资源。 同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。

    5. 处理机分给线程，即真正在处理机上运行的是线程。

    6. 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。

    `协程`：是轻量级的线程，一个进程可轻松创建数十万计的协程。协程的调度完全由用户控制。

    `线程和协程的区别`：

    1. 一个线程可以多个协程，一个进程也可以单独拥有多个协程

    2. 线程是抢占式，而协程是非抢占式的，所以需要用户自己释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。

    **参考**：

    - [每个程序员都会遇到的面试问题：谈谈进程和线程的区别](https://www.cnblogs.com/jobbible/p/9766649.html)

    - [【linux操作系统】进程和线程](https://blog.csdn.net/xing1584114471/article/details/92793556)

    - [协程与线程的区别](https://blog.csdn.net/fadbgfnbxb/article/details/88787361)

    ---

- **TCP 和 UDP 的区别**：

    1. TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接

    2. TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付

    3. TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的。UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）

    4. 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信

    5. TCP首部开销20字节;UDP的首部开销小，只有8个字节

    6. TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

    **参考**：

- **TCP 三次握手和四次挥手，为什么？**

    - [TCP的三次握手与四次挥手理解及面试题（很全面）](https://blog.csdn.net/qq_38950316/article/details/81087809)

- **进程间的通信方式和对应的同步方式**：

    - 管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。

    - 信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。不是用于交换大批数据,而用于多线程之间的同步.常作为一种锁机制,防止某进程在访问资源时其它进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

    - 消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

    - 共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。

    - 套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。

    线程间的同步方式有四种：

    - 临界区
    临界区对应着一个CcriticalSection对象，当线程需要访问保护数据时，调用EnterCriticalSection函数；当对保护数据的操作完成之后，调用LeaveCriticalSection函数释放对临界区对象的拥有权，以使另一个线程可以夺取临界区对象并访问受保护的数据。
    PS:关键段对象会记录拥有该对象的线程句柄即其具有“线程所有权”概念，即进入代码段的线程在leave之前，可以重复进入关键代码区域。所以关键段可以用于线程间的互斥，但不可以用于同步（同步需要在一个线程进入，在另一个线程leave）

    - 互斥量
    互斥与临界区很相似，但是使用时相对复杂一些（互斥量为内核对象），不仅可以在同一应用程序的线程间实现同步，还可以在不同的进程间实现同步，从而实现资源的安全共享。
    PS:1、互斥量由于也有线程所有权的概念，故也只能进行线程间的资源互斥访问，不能由于线程同步；
    2、由于互斥量是内核对象，因此其可以进行进程间通信，同时还具有一个很好的特性，就是在进程间通信时完美的解决了”遗弃”问题

    - 信号量
    信号量的用法和互斥的用法很相似，不同的是它可以同一时刻允许多个线程访问同一个资源，PV操作
    PS:事件可以完美解决线程间的同步问题，同时信号量也属于内核对象，可用于进程间的通信

    - 事件
    事件分为手动置位事件和自动置位事件。事件Event内部它包含一个使用计数（所有内核对象都有），一个布尔值表示是手动置位事件还是自动置位事件，另一个布尔值用来表示事件有无触发。由SetEvent()来触发，由ResetEvent()来设成未触发。
    PS:事件是内核对象,可以解决线程间同步问题，因此也能解决互斥问题

    **参考**：[线程间的通信、同步方式与进程间通信方式](https://blog.csdn.net/qq_32621445/article/details/78635951)

- **TCP如何保证传输的可靠性？**

    - 校验和

    - 序列号

    - 确认应答

    - 超时重传

    - 连接管理

    - 流量控制

    - 拥塞控制

    **参考**：[网络基础：TCP协议-如何保证传输可靠性](https://blog.csdn.net/liuchenxia8/article/details/80428157)

- **TCP的拥塞控制，具体过程是怎么样的？UDP有拥塞控制吗？如何解决？**

    **参考**：[网络基础：TCP协议-如何保证传输可靠性](https://blog.csdn.net/liuchenxia8/article/details/80428157)

- **redis 有哪几种数据类型？你比较熟悉哪几种？为什么？**

    **参考**：[菜鸟教程](https://www.runoob.com/redis/redis-tutorial.html)

- **redis 中集合和有序集合有什么区别**：

    **参考**：[菜鸟教程](https://www.runoob.com/redis/redis-tutorial.html)

- **讲讲 redis 里面的哈希表**：

    **参考**：[菜鸟教程](https://www.runoob.com/redis/redis-tutorial.html)

- **Redis底层是怎么存储数据**：

    **参考**：[Redis（三）--- Redis的五大数据类型的底层实现](https://www.cnblogs.com/MouseDong/p/11134039.html)

- **redis底层数据结构有哪些**：

    1. 简单动态字符串

    2. 链表

    3. 哈希表

    4. 跳跃表

    5. 整数集合

    6. 压缩列表

    **参考**：

    - [Redis详解（四）------ redis的底层数据结构](https://www.cnblogs.com/ysocean/p/9080942.html)

    - [Redis（三）--- Redis的五大数据类型的底层实现](https://www.cnblogs.com/MouseDong/p/11134039.html)

- **Redis 有序集合的原理**：

    **参考**：[Redis:有序集合类型zset实现原理](https://www.jianshu.com/p/35bce2ea5743)

- **Redis集群上如何保证数据的同步**：

    **参考**：[字节跳动后端开发实习生面试](https://www.nowcoder.com/discuss/368560)

- **cookie 和 session 的区别**：

    1. 存储位置不同：cookie 存放在客户端浏览器上，session 存放在服务器中

    2. 存储容量不同：单个 cookie 保存的数据 <=4k，一个站点最多保存 20 个cookie。session 理论上没有限制，不过为了服务器性能，session 内不要放置过多的东西，且设置 session 删除机制。

    3. 隐私策略不同：cookie 对客户端可见，其它人可以分析存放在本地的 cookie 进行 cookie 欺骗。所以它不安全。session 对客户端是透明的，不存在敏感数据泄露的风险。

    4. 服务器压力不同：cookie 保存在客户端，不会给服务器造成压力；session 保存在服务端，每个用户都会产生一个 session，耗费大量内存。

    5. 跨域支持不同：cookie 支持跨域访问；session 不支持跨域访问。

    **参考**：[Cookie和Session的区别](https://www.jianshu.com/p/2f7031a69f43)

- **session 在服务器上以怎样的形式存在**：

    可以存储在内存中。不过也可以做持久化存储。如：文件、数据库等。

    **参考**：[Session是怎么实现的？存储在哪里？](https://blog.csdn.net/qq_15096707/article/details/74012116?utm_source=distribute.pc_relevant.none-task)

- **Http与Https的区别**：

    1、https协议需要到CA  （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。

    2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

    3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

    4、http的连接很简单，是无状态的。Https协议是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

    **参考**：[Http和Https的区别（面试常考题）](https://blog.csdn.net/qq_38289815/article/details/80969419)

- **死锁的四个必要条件**：

    - 互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。

    - 请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。

    - 不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。

    - 循环等待条件: 若干进程间形成首尾相接循环等待资源的关系

    这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。

- **大文件去重**：

    bloomfilter 和 map reduce 两种方法

    **参考**：

    - [BloomFilter——大规模数据处理利器](https://www.cnblogs.com/heaad/archive/2011/01/02/1924195.html)

    - [【每日N题】由海量数据去重所想到的，面试思维惯式](https://blog.csdn.net/sunxinhere/article/details/8011144)

- **HTTP状态码分类**：

    - 1**：信息，服务器收到请求，需要请求者继续执行操作

    - 2**：成功，操作被成功接收并处理

    - 3**：重定向，需要进一步的操作以完成请求

    - 4**：客户端错误，请求包含语法错误或无法完成请求

    - 5**：服务器错误，服务器在处理请求的过程中发生了错误

- **从输入网址到获得页面的网络请求的过程**：

    - 域名解析

    - 建立TCP连接

    - 根据SpringMVC后台业务返回数据，并把数据填充到HTML页面上，然后返回给浏览器

    - 浏览器进行处理

    - 绘制网页

    **参考**：[从输入网址到获得页面的网络请求的过程](https://blog.csdn.net/qq_36520235/article/details/82559847)

- **RPC 原理和框架**：

    RPC 的全称是 Remote Procedure Call 是一种进程间通信方式。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即无论是调用本地接口/服务的还是远程的接口/服务，本质上编写的调用代码基本相同。

    ![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1gc3uryvkkaj30m30hy43f.jpg)

    **参考**：[RPC原理及实现](https://www.cnblogs.com/twinhead/p/9900605.html)

- **讲一下单点登录**：

    在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。

    **参考**：[什么是单点登录？](https://www.cnblogs.com/suim1218/p/7699041.html)

- **如果在某一时刻有大量的缓存失效，有大量的请求落到数据库上，怎么处理**：

    **参考**：[缓存穿透、缓存击穿和缓存雪崩实践 侵删](https://blog.csdn.net/qq_22167989/article/details/100860288)

- **讲一下分布式锁，如何实现**：

    分布式锁是控制分布式系统或不同系统之间共同访问共享资源的一种锁实现，如果不同的系统或同一个系统的不同主机之间共享了某个资源时，往往需要互斥来防止彼此干扰来保证一致性。

    **参考**：

    1. [分布式锁](https://blog.csdn.net/zhouwei1221q/article/details/71457006)

    2. [三种实现分布式锁的方式](https://blog.csdn.net/wuzhiwei549/article/details/80692278)

- **更新数据的时候是先更新redis还是mysql**：

    先更新DB再删除缓存（使用场景多）

    **参考**：[更新数据时，是先删除缓存再更新DB，还是先更新DB再删除缓存？](https://blog.csdn.net/wangxin1982314/article/details/89317465)

- **介绍一下垃圾回收机制及垃圾回收算法**:

    垃圾回收机制专门用来回收不可用的变量值所占用的内存空间

    1. 引用计数

    2. 标记-清除

    3. 分代收集

    **参考**：
    
    1. [垃圾回收机制](https://www.cnblogs.com/12345huangchun/p/10217342.html)

    2. [GO语言垃圾回收机制](https://studygolang.com/articles/25096?fr=sidebar)

- **面向对象的特性**：

    1. 对象唯一性

    2. 抽象性

    3. 继承性

    4. 多态性

    **参考**：[面向对象特性]

- **操作系统中进程调度策略**：

    1. FCFS(先来先服务)

    2. 优先级

    3. 时间片轮转

    4. 多级反馈-调度算法

    **参考**：[操作系统中进程调度策略有哪几种？](https://www.cnblogs.com/hjh-666/p/11449470.html)

- linux 中如何创建进程

    在Linux系统中，除了系统启动之后的第一个进程由系统来创建，其余的进程都必须由已存在的进程来创建，新创建的进程叫做子进程，而创建子进程的进程叫做父进程。那个在系统启动及完成初始化之后，Linux自动创建的进程叫做根进程。根进程是Linux中所有进程的祖宗，其余进程都是根进程的子孙。具有同一个父进程的进程叫做兄弟进程。

    在Linux中，父进程以分裂的方式来创建子进程，创建一个子进程的系统调用叫做fork()。

    ![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1gc9josr63zj30fm080wg5.jpg)

    **参考**：[【Linux】Linux进程的创建与管理](https://blog.csdn.net/qq_38410730/article/details/81193118)