# 知识点

==学习网站：[https://tour.go-zh.org/list](https://tour.go-zh.org/list)，除了这个官方网站以外也可以结合菜鸟教程一起学习==

==go 语言中处理字符串的函数主要在 strings 包中==

## 1. Go函数作为值与类型

在 Go 语言中，我们可以把函数作为一种变量，用 type 去定义它，那么这个函数类型就可以作为值传递，甚至可以实现方法，有时候我们甚至可以利用这一特性进行类型转换。作为值传递的条件是类型具有相同的参数以及相同的返回值。

### 1.1 函数的类型转换

```go
package main

import "fmt"

type CalculateType func(int, int) // 声明了一个函数类型

// 该函数类型实现了一个方法
func (c *CalculateType) Serve() {
  fmt.Println("我是一个函数类型")
}

// 加法函数
func add(a, b int) {
  fmt.Println(a + b)
}

// 乘法函数
func mul(a, b int) {
  fmt.Println(a * b)
}

func main() {
  a := CalculateType(add) // 将add函数强制转换成CalculateType类型
  b := CalculateType(mul) // 将mul函数强制转换成CalculateType类型
  a(2, 3)
  b(2, 3)
  a.Serve()
  b.Serve()
}

// 5
// 6
// 我是一个函数类型
// 我是一个函数类型
```

如上，声明了一个 CalculateType 函数类型，并实现 Serve() 方法，并将拥有相同参数的 add 和 mul 强制转换成 CalculateType 函数类型，同时这两个函数都拥有了 CalculateType 函数类型的 Serve() 方法。

### 1.2 函数作参数传递

```go
package main

import "fmt"

type CalculateType func(a, b int) int // 声明了一个函数类型

// 加法函数
func add(a, b int) int {
  return a + b
}

// 乘法函数
func mul(a, b int) int {
  return a * b
}

func Calculate(a, b int, f CalculateType) int {
  return f(a, b)
}

func main() {
  a, b := 2, 3
  fmt.Println(Calculate(a, b, add))
  fmt.Println(Calculate(a, b, mul))
}
// 5
// 6
```

如上例子，Calculate 的 f 参数类型为 CalculateType，add 和 mul 函数具有和 CalculateType 函数类型相同的参数和返回值，因此可以将 add 和 mul 函数作为参数传入 Calculate 函数中。

**参考**：[http://objcoding.com/2017/12/27/Go-functions-as-values-and-types/](http://objcoding.com/2017/12/27/Go-functions-as-values-and-types/)

---

## 2. 空接口 interface{}

空接口是接口类型的特殊形式，空接口没有任何方法，因此任何类型都无须实现空接口。从实现的角度看，任何值都满足这个接口的需求。因此空接口类型可以保存任何值，也可以从空接口中取出原值。

**提示**:

空接口类型类似于 C# 或 Java 语言中的 Object、C语言中的 void*、C++ 中的 std::any。在泛型和模板出现前，空接口是一种非常灵活的数据抽象保存和使用的方法。

**参考**：[Go语言空接口类型（interface{}）](http://c.biancheng.net/view/84.html)

---

## 3. 临时对象池sync.Pool

在高并发或者大量的数据请求的场景中，我们会遇到很多问题，垃圾回收就是其中之一（garbage collection），为了减少优化GC，我们一般想到的方法就是能够让对象得以重用。这就需要一个对象池来存储待回收对象，等待下次重用，从而减少对象产生数量。我们可以把sync.Pool类型值看作是存放可被重复使用的值的容器。此类容器是自动伸缩的、高效的，同时也是并发安全的

**案例**:

```go
package main

import(
    "fmt"
    "sync"
)

func main() {
    p := &sync.Pool{
        New: func() interface{} {
            return 0
        },
    }

    a := p.Get().(int)
    p.Put(1)
    b := p.Get().(int)
    fmt.Println(a, b)
```

**参考**：

- [go语言的官方包sync.Pool的实现原理和适用场景](https://blog.csdn.net/yongjian_lian/article/details/42058893)

- [golang的临时对象池sync.Pool](http://www.01happy.com/golang-sync-pool/)

---

## sync.Mutex 和 sync.RWMutex

Mutex：互斥锁

RWMutex：读写锁，RWMutex 基于 Mutex 实现

### Mutex 互斥锁

- Mutex 为互斥锁，Lock() 加锁，Unlock() 解锁

- 在一个 goroutine 获得 Mutex 后，其他 goroutine 只能等到这个 goroutine 释放该 Mutex

- 使用 Lock() 加锁后，不能再继续对其加锁，直到利用 Unlock() 解锁后才能再加锁

- 在 Lock() 之前使用 Unlock() 会导致 panic 异常

- 已经锁定的 Mutex 并不与特定的 goroutine 相关联，这样可以利用一个 goroutine 对其加锁，再利用其他 goroutine 对其解锁

- 在同一个 goroutine 中的 Mutex 解锁之前再次进行加锁，会导致死锁
适用于读写不确定，并且只有一个读或者写的场景

### RWMutex 读写锁

- RWMutex 是单写多读锁，该锁可以加多个读锁或者一个写锁

- 读锁占用的情况下会阻止写，不会阻止读，多个 goroutine 可以同时获取读锁

- 写锁会阻止其他 goroutine（无论读和写）进来，整个锁由该 goroutine 独占

- 适用于读多写少的场景

#### Lock() 和 Unlock()

- Lock() 加写锁，Unlock() 解写锁

- 如果在加写锁之前已经有其他的读锁和写锁，则 Lock() 会阻塞直到该锁可用，为确保该锁可用，已经阻塞的 Lock() 调用会从获得的锁中排除新的读取器，即写锁权限高于读锁，有写
锁时优先进行写锁定

- 在 Lock() 之前使用 Unlock() 会导致 panic 异常

#### RLock() 和 RUnlock()

- RLock() 加读锁，RUnlock() 解读锁

- RLock() 加读锁时，如果存在写锁，则无法加读锁；当只有读锁或者没有锁时，可以加读锁，读锁可以加载多个

- RUnlock() 解读锁，RUnlock() 撤销单词 RLock() 调用，对于其他同时存在的读锁则没有效果

- 在没有读锁的情况下调用 RUnlock() 会导致 panic 错误

- RUnlock() 的个数不得多余 RLock()，否则会导致 panic 错误

**参考**：[golang 中 sync.Mutex 和 sync.RWMutex](https://www.jianshu.com/p/679041bdaa39)

---

## 4. reflect 反射

允许程序操纵对象的值和类型

**参考**：[https://colobu.com/2016/07/09/dive-into-go-13/](https://colobu.com/2016/07/09/dive-into-go-13/)

---

## 5. 函数闭包

Go 语言支持匿名函数，可作为闭包。匿名函数是一个"内联"语句或表达式。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。

以下实例中，我们创建了函数 getSequence() ，返回另外一个函数。该函数的目的是在闭包中递增 i 变量，代码如下：

```go
package main

import "fmt"

func getSequence() func() int {
   i:=0
   return func() int {
      i+=1
     return i  
   }
}

func main(){
   /* nextNumber 为一个函数，函数 i 为 0 */
   nextNumber := getSequence()  

   /* 调用 nextNumber 函数，i 变量自增 1 并返回 */
   fmt.Println(nextNumber())   //输出1
   fmt.Println(nextNumber())   //输出2
   fmt.Println(nextNumber())   //输出3
   
   /* 创建新的函数 nextNumber1，并查看结果 */
   nextNumber1 := getSequence()  
   fmt.Println(nextNumber1())  //输出1
   fmt.Println(nextNumber1())  //输出2
}
```

**参考**：[Go 语言函数闭包](http://www.runoob.com/go/go-function-closures.html)

---

## 6. GoLang中 json、map、struct 之间的相互转化

**参考**：[GoLang中 json、map、struct 之间的相互转化](https://www.cnblogs.com/liang1101/p/6741262.html)

---

## 7. Go语言的接口interface、struct和组合、继承

**参考**：[Go语言的接口interface、struct和组合、继承](https://www.cnblogs.com/pluse/p/7655977.html)

---

## 8. 数组和切片的区别

**golang array 特点**：

- array是固定长度的数组，使用前必须确定数组长度

- golang中的数组是值类型,也就是说，如果你将一个数组赋值给另外一个数组，那么，实际上就是整个数组拷贝了一份

- 如果golang中的数组作为函数的参数，那么实际传递的参数是一份数组的拷贝，而不是数组的指针

- array的长度也是Type的一部分，这样就说明[10]int和[20]int是不一样的。

**slice 类型**:

- slice是一个引用类型，是一个动态的指向数组切片的指针。

- slice是一个不定长的，总是指向底层的数组array的数据结构。

==作为函数参数时，数组传递的是数组的副本，而slice传递的是指针==

### 8.1. 声明方式

#### 8.1.1. 数组

`var variable_name [SIZE] variable_type`

如：`var balance [10] float32`

#### 8.1.2 切片

`var identifier []type`

 `var slice1 []type = make([]type, len)` or `slice1 := make([]type, len)` or `slice1 := make([]T, length, capacity)`

### 8.2. 初始化

#### 8.2.1 数组

`var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}`

`var balance = [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}`

#### 8.2.2. 切片

`s :=[] int {1,2,3 }`

此外，直接从数组或切片中截取获得的对象也是切片，如

```go
var arr =[10]{1,2,3,4,5,6}  
sl := arr[2:5] //创建有3个元素的slice
```

**参考**：

- [goLang slice 和 array区别](https://segmentfault.com/a/1190000013148775)

- [Go 语言数组](https://www.runoob.com/go/go-arrays.html)

- [Go 语言切片(Slice)](https://www.runoob.com/go/go-slice.html)

---

## 9. iota

iota，特殊常量，可以认为是一个可以被编译器修改的常量。

iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。

iota 可以被用作枚举值：

```go
const (
    a = iota
    b = iota
    c = iota
)
```

第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a=0, b=1, c=2 可以简写为如下形式：

```go
const (
    a = iota
    b
    c
)
```

```go
package main

import "fmt"

func main() {
    const (
            a = iota   //0
            b          //1
            c          //2
            d = "ha"   //独立值，iota += 1
            e          //"ha"   iota += 1
            f = 100    //iota +=1
            g          //100  iota +=1
            h = iota   //7,恢复计数
            i          //8
    )
    fmt.Println(a,b,c,d,e,f,g,h,i)
```

以上实例运行结果为：

`0 1 2 ha ha 100 100 7 8`

**参考**：[Go 语言常量](https://www.runoob.com/go/go-constants.html)

---

## 10. time 包

**time 组成**：

1. time.Duration（时间长度，消耗时间）

2. time.Time（时间点）

3. time.C（放时间的channel通道）（注：Time.C:=make(chan time.Time)）

### 10.1 函数

- `func After(d Duration) <-chan Time`：表示多少时间之后，但是在取出channel内容之前不阻塞，后续程序可以继续执行

- `func Sleep(d Duration)`：表示休眠多少时间，休眠时处于阻塞状态，后续程序无法执行．

  举例说明二者区别：

  ```go
    fmt.Println("hello")

    chan := time.After(time.Secone*1)

    fmt.Println("World")
  ```

  则程序在执行完输出hello后，接着便输出world，不用等待１s，但是１s后，chan中有数据，此时chan阻塞

  ```go
    mt.Println("hello")

    chan := time.Sleep(time.Secone*1)

    fmt.Println("World")
  ```

  则表示在输出hello后，程序变休眠1s中，然后才输出World．由此可见阻塞和非阻塞便是这两个函数的本质区别．

  鉴于After特性，其通常用来处理程序超时问题，如下所示：

  ```go
    select {
    case m := <-c:
        handle(m)
    case <-time.After(5 * time.Minute):
        fmt.Println("timed out")
    }
  ```

- `func Tick(d Duration) <-chan Time`：time.Tick(time.Duration)用法和time.After差不多，`但是它是表示每隔多少时间之后，是一个重复的过程`，其他与After一致

- type Duration int64：时间长度，其对应的时间单位有Nanosecond，Microsecond,Millisecond,Second,Minute,Hour

  ```go
    type Duration int64

    const (
      Nanosecond  Duration = 1
      Microsecond          = 1000 * Nanosecond
      Millisecond          = 1000 * Microsecond
      Second               = 1000 * Millisecond
      Minute               = 60 * Second
      Hour                 = 60 * Minute
    )
  ```

- Ticker类型：Ticker 类型包含一个 channel，有时我们会遇到每隔一段时间执行的业务(比如设置心跳时间等)，就可以用它来处理，这是一个重复的过程

- Timer类型：Timer 类型用来代表一个单独的事件，当设置的时间过期后，发送当前的时间到 channel, 我们可以通过以下两种方式来创建

**参考**：

- [golang中time包用法](https://studygolang.com/articles/4331?fr=sidebar)

- [golang package time 用法详解](https://juejin.im/post/5ae32a8651882567105f7dd3)

---

## 11. 精密计算和 big 包

我们知道有些时候通过编程的方式去进行计算是不精确的。如果你使用 Go 语言中的 float64 类型进行浮点运算，返回结果将精确到 15 位，足以满足大多数的任务。当对超出 int64 或者 uint64 类型这样的大数进行计算时，如果对精度没有要求，float32 或者 float64 可以胜任，但如果对精度有严格要求的时候，我们不能使用浮点数，在内存中它们只能被近似的表示。

**参考**：[精密计算和 big 包](https://wiki.jikexueyuan.com/project/the-way-to-go/09.4.html)

---

## 12. new和make的区别

Go语言中new和make是内建的两个函数，主要用来创建分配类型内存

变量的声明我们可以通过var关键字，然后就可以在程序中使用。当我们不指定变量的默认值时，这些变量的默认值是他们的零值，比如int类型的零值是0,string类型的零值是""，引用类型的零值是nil。

make 和 new 不同，它只用于chan、map以及切片的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。

二者都是内存的分配（堆上），但是make只用于slice、map以及channel的初始化（非零值）；而new用于类型的内存分配，并且内存置为零。

make返回的还是这三个引用类型本身；而new返回的是指向类型的指针

**参考**：[Go语言中new和make的区别](https://www.flysnow.org/2017/10/23/go-new-vs-make.html)

---

## 13. 指针

```go
package main

import "fmt"

func swap(a, b *int) {
    b, a = a, b
}

func main() {
    x, y := 1, 2
    swap(&x, &y)
    fmt.Println(x, y)
}
```

`运行结果：1 2`

结果表明，交换是不成功的。上面代码中的 swap() 函数交换的是 a 和 b 的地址，在交换完毕后，a 和 b 的变量值确实被交换。但和 a、b 关联的两个变量并没有实际关联。这就像写有两座房子的卡片放在桌上一字摊开，交换两座房子的卡片后并不会对两座房子有任何影响。

**参考**：[Go语言指针详解，看这一篇文章就够了](http://c.biancheng.net/view/21.html)

---

## 14. channel 详解

Channel是Go中的一个核心类型，你可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯

Channel可以作为一个先入先出(FIFO)的队列，接收的数据和发送的数据的顺序是一致的。

就像 map 和 slice 数据类型一样, channel必须先创建再使用(箭头的指向就是数据的流向):

```go
ch := make(chan int)
```

```go
chan T          // 可以接收和发送类型为 T 的数据
chan<- float64  // 只可以用来发送 float64 类型的数据，也称 `发送方`
<-chan int      // 只可以用来接收 int 类型的数据，也称 `接收方`
```

**检查 Channel 是否被关闭**：

```go
v, ok := <-ch
```

==默认情况下，通道是不带缓冲区的。发送端发送数据，同时又必须接收相应的接收数据。如果没有缓冲区，但是又只有发送端发送数据，则会出现下面的错误（死锁）==

```go
  func main() {
    test := make(chan int)
    test <- 5
    fmt.Println(<-test)
  }
```

![2](http://ww1.sinaimg.cn/large/006alGmrly1g3afv44qpdj30in05r74o.jpg)

==解决方法就是用 go 关键字开启一个线程。无缓存的channel只有在receiver准备好后send才被执行。如下==

```go
  func main() {
    test := make(chan int)
    go func() {test <- 5}()
    fmt.Println(<-test)
  }
  //5
```

**参考**：

- [Go Channel 详解](https://colobu.com/2016/04/14/Golang-Channels/)

- [菜鸟教程 - Go 并发](https://www.runoob.com/go/go-concurrent.html)

---

## 15. select关键字

select就是用来监听和channel有关的IO操作，当 IO 操作发生时，触发相应的动作。

```go
//select基本用法
select {
case <- chan1:
// 如果chan1成功读到数据，则进行该case处理语句
case chan2 <- 1:
// 如果成功向chan2写入数据，则进行该case处理语句
default:
// 如果上面都没有成功，则进入default处理流程
```

**参考**：

- [select关键字用法](https://studygolang.com/articles/15740)

---

## 16. 空 struct{} 用法

golang 空结构体 struct{} 可以用来节省内存，用来单纯的做控制信息

```go
a := struct{}{}
println(unsafe.Sizeof(a))
// Output: 0
```

两个空结构体的地址相等

```go
var a, b struct{}
fmt.Println(&a == &b) // true
```

==用法 1==：下例说明在map里节省资源的用途：

```go
set := make(map[string]struct{})
for _, value := range []string{"apple", "orange", "apple"} {
   set[value] = struct{}{}
}
fmt.Println(set)
// Output: map[orange:{} apple:{}]
```

==用法 2==：下例，演示了struct{}可以向人展示对象中不需要任何数据，仅包含需要方法。

```go
type Lamp struct{}

func (l Lamp) On() {
        println("On")

}
func (l Lamp) Off() {
        println("Off")
}

func main() {
       	// Case #1.
       	var lamp Lamp
       	lamp.On()
       	lamp.Off()
       	// Output:
       	// on
       	// off
	
       	// Case #2.
       	Lamp{}.On()
       	Lamp{}.Off()
       	// Output: 
       	// on
       	// off
}
```

==用法 3==：使用channel，但并不需要附带任何数据

```go
func worker(ch chan struct{}) {
	// Receive a message from the main program.
	<-ch
	println("roger")
	
	// Send a message to the main program.
	close(ch)
}

func main() {
	ch := make(chan struct{})
	go worker(ch)
	
	// Send a message to a worker.
	ch <- struct{}{}
	
	// Receive a message from the worker.
	<-ch
	println(“roger")
	// Output:
	// roger
	// roger
}
```

**参考**：

- [Golang空结构体struct{}用途，你知晓么?](https://blog.csdn.net/weixin_44328662/article/details/86501900)

- [golang 空结构体struct{}解析](https://blog.csdn.net/a64180190/article/details/76615561)

---

## 17. 三个点 ... 的作用

‘…’ 其实是go的一种语法糖。
它的第一个用法主要是用于函数有多个不定参数的情况，可以接受多个不确定数量的参数。
第二个用法是slice可以被打散进行传递。

```go
func test1(args ...string) { //可以接受任意个string参数
    for _, v:= range args{
        fmt.Println(v)
    }
}

func main(){
var strss= []string{
        "qwr",
        "234",
        "yui",
        "cvbc",
    }
    test1(strss...) //切片被打散传入
}
//qwr
//234
//yui
//cvbc
```

```go
    var strss= []string{
        "qwr",
        "234",
        "yui",

    }
    var strss2= []string{
        "qqq",
        "aaa",
        "zzz",
        "zzz",
    }
strss=append(strss,strss2...) //strss2的元素被打散一个个append进strss
fmt.Println(strss)
//[qwr 234 yui qqq aaa zzz zzz]
```

如果没有’…’，面对上面的情况，无疑会增加代码量，有了’…’，使代码变得更加简洁

**参考**：[golang中的三个点 '...' 的用法](https://blog.csdn.net/jeffrey11223/article/details/79166724)

---

## 18. init函数和main函数

go 语言中 init 函数用于包 (package) 的初始化，该函数是 go 语言的一个重要特性。

Go语言程序的默认入口函数(主函数)：func main()

两个函数在定义时不能有任何的参数和返回值，且Go程序自动调用。

init可以应用于任意包中，且可以重复定义多个。

==main函数只能用于main包中，且只能定义一个。==

**参考**：[init函数和main函数](https://www.kancloud.cn/liupengjie/go/570013)

---

## 19. 命名规范及大小写的访问权限

- golang的命名需要使用驼峰命名法，且不能出现下划线

- golang中根据首字母的大小写来确定可以访问的权限。无论是方法名、常量、变量名还是结构体的名称，如果首字母大写，则可以被其他的包访问；如果首字母小写，则只能在本包中使用

  ==可以简单的理解成，首字母大写是公有的，首字母小写是私有的==

- 结构体中属性名

  如果属性名小写则在数据解析（如json解析,或将结构体作为请求或访问参数）时无法解析

  ```go
    type User struct {

          name string

          age  int

     }

    func main() {

             user:=User{"Tom",18}

             if userJSON,err:=json.Marshal(user);err==nil{

           　　  fmt.Println(string(userJSON))   //数据无法解析

            }
    }
  ```

   如上面的例子，如果结构体中的字段名为小写，则无法数据解析。所以一般建议结构体中的字段大写

- 如果包 1 中结构体名为大写 Struct1，则包 2 可以调用它
  如果包 1 中结构体名为大写 Struct1，但是有一个小写结构体变量声明 var struct Struct1，则包 2 不可以调用 struct 变量
  如果包 1 中结构体名为大写 Struct1，结构体变量声明为大写 var Struct Struct1，则包 2 可以调用 Struct 变量
  如果包 1 中结构体名为大写 Struct1，但是属性名为小写，则包 2 无法调用该结构体的属性。同理，如果结构体 Struct1 的方法名为小写，则包 2 也无法调用该方法名
  ==本条结论参考链接 2，注意：如果调用发生在同一个包类，不管大小写，都没关系==

**参考**：

- [golang的命名规范及大小写的访问权限](https://blog.csdn.net/skh2015java/article/details/54316195)

- [结构体的可访问性](https://www.cnblogs.com/xiaopipi/p/4955861.html)

---

## 20. 构造函数

构造函数 ，是一种特殊的方法。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。特别的一个类可以有多个构造函数 ，可根据其参数个数的不同或参数类型的不同来区分它们 即构造函数的重载。

而golang没有相关的构造函数定义，只能通过new来创建构造函数。

**声明一个struct结构**：

![2](http://ww1.sinaimg.cn/large/006alGmrly1g3adrs7vdbj308o03cmx2.jpg)

**声明一个全局函数，返回`*struct`**

![2](http://ww1.sinaimg.cn/large/006alGmrly1g3adsucoorj30e0045q30.jpg)

ok，到此已经构造函数定义完毕

**参考**：[golang语言构造函数](https://www.cnblogs.com/zsy/p/5858800.html)

---

## 21. 常用类型之间的转换

### 1. string 转 int 或其它

先使用 strconv.ParseInt(s,10,64), 转换成相对应的int64，然后使用强制转换。例如：

```go
  r,_ := strconv.ParseInt("123",10,64)
  fmt.Println(int(r))
```

此外还可以使用 `int,err:=strconv.Atoi(string)`

其它转换可以参考下面链接

### 2. int 或其它转 string

```go
fmt.Println(strconv.FormatInt(int64(500), 10))
```

此外还可以使用 `string:=strconv.Itoa(int)`

其它转换可以参考下面链接

### 3. 其它

注意如下代码输出：

```go
test := '1'
fmt.Println(test)
//49
```

go 语言对字节类型的输出为其对应的 asc ii 码。这一点在遍历字符串时需要格外注意，如 `fmt.Println("123"[2])` 的输出其实是 51。

将 asc ii 码转换为对应的字符，直接使用 `string("123"[2])` 即可。如下：

```go
fmt.Println("123"[2])
fmt.Println(string("123"[2]))
//51
//3  
```

**string 转 array**：

```go
fmt.Println([]byte("qiubing"))
fmt.Println([]uint8("qiubing"))
```

**参考**：

- [Go中的各种变量类型转换](http://www.hangdaowangluo.com/archives/2077)

- [go语言string、int、int64互相转换](https://blog.csdn.net/pkueecser/article/details/50433460)

---

## 22. atomic原子操作

atomic是最轻量级的锁,在一些场景下直接使用atomic包还是很有效的。

CAS操作的优势是，可以在不形成临界区和创建互斥量的情况下完成并发安全的值替换操作。
这可以大大的减少同步对程序性能的损耗。  

当然，CAS操作也有劣势。在被操作值被频繁变更的情况下，CAS操作并不那么容易成功。

**原子操作共有5种，即：增或减、比较并交换、载入、存储和交换**：

- 增：`func AddUint32(addr *uint32, delta uint32) (new uint32)`

- 减：和增类似，把 delta 换个符号即可

- 比较并交换：`func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)`

- 载入：`func LoadInt32(addr *int32) (val int32)`

- 存储：`func StoreInt32(addr *int32, val int32)`

**参考**：

- [Go语言atomic原子操作](https://studygolang.com/articles/3557)

- [golang atomic包的使用](https://www.jianshu.com/p/228c119a7d0e)

---

## 23. strings 包，字符串切割

```go
import (
 "fmt"
 "strings"
)
func main() {
 fmt.Println(strings.Split("a,b,c,d,e", ",")) //[a b c d e]
}
```

其它还有很多方法，可以参考链接

**参考**：[Go语言编程中字符串切割方法小结](https://www.jb51.net/article/73984.htm)
