# 知识点

==学习网站：[https://tour.go-zh.org/list](https://tour.go-zh.org/list)，除了这个官方网站以外也可以结合菜鸟教程一起学习==

==go 语言中处理字符串的函数主要在 strings 包中==

## 1. Go函数作为值与类型

在 Go 语言中，我们可以把函数作为一种变量，用 type 去定义它，那么这个函数类型就可以作为值传递，甚至可以实现方法，有时候我们甚至可以利用这一特性进行类型转换。作为值传递的条件是类型具有相同的参数以及相同的返回值。

### 1.1 函数的类型转换

```go
package main

import "fmt"

type CalculateType func(int, int) // 声明了一个函数类型

// 该函数类型实现了一个方法
func (c *CalculateType) Serve() {
  fmt.Println("我是一个函数类型")
}

// 加法函数
func add(a, b int) {
  fmt.Println(a + b)
}

// 乘法函数
func mul(a, b int) {
  fmt.Println(a * b)
}

func main() {
  a := CalculateType(add) // 将add函数强制转换成CalculateType类型
  b := CalculateType(mul) // 将mul函数强制转换成CalculateType类型
  a(2, 3)
  b(2, 3)
  a.Serve()
  b.Serve()
}

// 5
// 6
// 我是一个函数类型
// 我是一个函数类型
```

如上，声明了一个 CalculateType 函数类型，并实现 Serve() 方法，并将拥有相同参数的 add 和 mul 强制转换成 CalculateType 函数类型，同时这两个函数都拥有了 CalculateType 函数类型的 Serve() 方法。

### 1.2 函数作参数传递

```go
package main

import "fmt"

type CalculateType func(a, b int) int // 声明了一个函数类型

// 加法函数
func add(a, b int) int {
  return a + b
}

// 乘法函数
func mul(a, b int) int {
  return a * b
}

func Calculate(a, b int, f CalculateType) int {
  return f(a, b)
}

func main() {
  a, b := 2, 3
  fmt.Println(Calculate(a, b, add))
  fmt.Println(Calculate(a, b, mul))
}
// 5
// 6
```

如上例子，Calculate 的 f 参数类型为 CalculateType，add 和 mul 函数具有和 CalculateType 函数类型相同的参数和返回值，因此可以将 add 和 mul 函数作为参数传入 Calculate 函数中。

**参考**：[http://objcoding.com/2017/12/27/Go-functions-as-values-and-types/](http://objcoding.com/2017/12/27/Go-functions-as-values-and-types/)

---

## 2. 空接口 interface{}

空接口是接口类型的特殊形式，空接口没有任何方法，因此任何类型都无须实现空接口。从实现的角度看，任何值都满足这个接口的需求。因此空接口类型可以保存任何值，也可以从空接口中取出原值。

**提示**:

空接口类型类似于 C# 或 Java 语言中的 Object、C语言中的 void*、C++ 中的 std::any。在泛型和模板出现前，空接口是一种非常灵活的数据抽象保存和使用的方法。

**参考**：[Go语言空接口类型（interface{}）](http://c.biancheng.net/view/84.html)

---

## 3. 临时对象池sync.Pool

在高并发或者大量的数据请求的场景中，我们会遇到很多问题，垃圾回收就是其中之一（garbage collection），为了减少优化GC，我们一般想到的方法就是能够让对象得以重用。这就需要一个对象池来存储待回收对象，等待下次重用，从而减少对象产生数量。我们可以把sync.Pool类型值看作是存放可被重复使用的值的容器。此类容器是自动伸缩的、高效的，同时也是并发安全的

**案例**:

```go
package main

import(
    "fmt"
    "sync"
)

func main() {
    p := &sync.Pool{
        New: func() interface{} {
            return 0
        },
    }

    a := p.Get().(int)
    p.Put(1)
    b := p.Get().(int)
    fmt.Println(a, b)
```

**参考**：

- [go语言的官方包sync.Pool的实现原理和适用场景](https://blog.csdn.net/yongjian_lian/article/details/42058893)

- [golang的临时对象池sync.Pool](http://www.01happy.com/golang-sync-pool/)

---

## 4. reflect 反射

允许程序操纵对象的值和类型

**参考**：[https://colobu.com/2016/07/09/dive-into-go-13/](https://colobu.com/2016/07/09/dive-into-go-13/)

---

## 5. 函数闭包

Go 语言支持匿名函数，可作为闭包。匿名函数是一个"内联"语句或表达式。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。

以下实例中，我们创建了函数 getSequence() ，返回另外一个函数。该函数的目的是在闭包中递增 i 变量，代码如下：

```go
package main

import "fmt"

func getSequence() func() int {
   i:=0
   return func() int {
      i+=1
     return i  
   }
}

func main(){
   /* nextNumber 为一个函数，函数 i 为 0 */
   nextNumber := getSequence()  

   /* 调用 nextNumber 函数，i 变量自增 1 并返回 */
   fmt.Println(nextNumber())   //输出1
   fmt.Println(nextNumber())   //输出2
   fmt.Println(nextNumber())   //输出3
   
   /* 创建新的函数 nextNumber1，并查看结果 */
   nextNumber1 := getSequence()  
   fmt.Println(nextNumber1())  //输出1
   fmt.Println(nextNumber1())  //输出2
}
```

**参考**：[Go 语言函数闭包](http://www.runoob.com/go/go-function-closures.html)

---

## 6. GoLang中 json、map、struct 之间的相互转化

**参考**：[GoLang中 json、map、struct 之间的相互转化](https://www.cnblogs.com/liang1101/p/6741262.html)

---

## 7. Go语言的接口interface、struct和组合、继承

**参考**：[Go语言的接口interface、struct和组合、继承](https://www.cnblogs.com/pluse/p/7655977.html)

---

## 8. 数组和切片的区别

**golang array 特点**：

- array是固定长度的数组，使用前必须确定数组长度

- golang中的数组是值类型,也就是说，如果你将一个数组赋值给另外一个数组，那么，实际上就是整个数组拷贝了一份

- 如果golang中的数组作为函数的参数，那么实际传递的参数是一份数组的拷贝，而不是数组的指针

- array的长度也是Type的一部分，这样就说明[10]int和[20]int是不一样的。

**slice 类型**:

- slice是一个引用类型，是一个动态的指向数组切片的指针。

- slice是一个不定长的，总是指向底层的数组array的数据结构。

==作为函数参数时，数组传递的是数组的副本，而slice传递的是指针==

### 8.1. 声明方式

#### 8.1.1. 数组

`var variable_name [SIZE] variable_type`

如：`var balance [10] float32`

#### 8.1.2 切片

`var identifier []type`

 `var slice1 []type = make([]type, len)` or `slice1 := make([]type, len)` or `slice1 := make([]T, length, capacity)`

### 8.2. 初始化

#### 8.2.1 数组

`var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}`

`var balance = [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}`

#### 8.2.2. 切片

`s :=[] int {1,2,3 }`

此外，直接从数组或切片中截取获得的对象也是切片，如

```go
var arr =[10]{1,2,3,4,5,6}  
sl := arr[2:5] //创建有3个元素的slice
```

**参考**：

- [goLang slice 和 array区别](https://segmentfault.com/a/1190000013148775)

- [Go 语言数组](https://www.runoob.com/go/go-arrays.html)

- [Go 语言切片(Slice)](https://www.runoob.com/go/go-slice.html)

---

## 9. iota

iota，特殊常量，可以认为是一个可以被编译器修改的常量。

iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。

iota 可以被用作枚举值：

```go
const (
    a = iota
    b = iota
    c = iota
)
```

第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a=0, b=1, c=2 可以简写为如下形式：

```go
const (
    a = iota
    b
    c
)
```

```go
package main

import "fmt"

func main() {
    const (
            a = iota   //0
            b          //1
            c          //2
            d = "ha"   //独立值，iota += 1
            e          //"ha"   iota += 1
            f = 100    //iota +=1
            g          //100  iota +=1
            h = iota   //7,恢复计数
            i          //8
    )
    fmt.Println(a,b,c,d,e,f,g,h,i)
```

以上实例运行结果为：

`0 1 2 ha ha 100 100 7 8`

**参考**：[Go 语言常量](https://www.runoob.com/go/go-constants.html)