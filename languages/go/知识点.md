# 知识点

==学习网站：[https://tour.go-zh.org/list](https://tour.go-zh.org/list)，除了这个官方网站以外也可以结合菜鸟教程一起学习==

==go 语言中处理字符串的函数主要在 strings 包中==

## 1. Go函数作为值与类型

在 Go 语言中，我们可以把函数作为一种变量，用 type 去定义它，那么这个函数类型就可以作为值传递，甚至可以实现方法，有时候我们甚至可以利用这一特性进行类型转换。作为值传递的条件是类型具有相同的参数以及相同的返回值。

### 1.1 函数的类型转换

```go
package main

import "fmt"

type CalculateType func(int, int) // 声明了一个函数类型

// 该函数类型实现了一个方法
func (c *CalculateType) Serve() {
  fmt.Println("我是一个函数类型")
}

// 加法函数
func add(a, b int) {
  fmt.Println(a + b)
}

// 乘法函数
func mul(a, b int) {
  fmt.Println(a * b)
}

func main() {
  a := CalculateType(add) // 将add函数强制转换成CalculateType类型
  b := CalculateType(mul) // 将mul函数强制转换成CalculateType类型
  a(2, 3)
  b(2, 3)
  a.Serve()
  b.Serve()
}

// 5
// 6
// 我是一个函数类型
// 我是一个函数类型
```

如上，声明了一个 CalculateType 函数类型，并实现 Serve() 方法，并将拥有相同参数的 add 和 mul 强制转换成 CalculateType 函数类型，同时这两个函数都拥有了 CalculateType 函数类型的 Serve() 方法。

### 1.2 函数作参数传递

```go
package main

import "fmt"

type CalculateType func(a, b int) int // 声明了一个函数类型

// 加法函数
func add(a, b int) int {
  return a + b
}

// 乘法函数
func mul(a, b int) int {
  return a * b
}

func Calculate(a, b int, f CalculateType) int {
  return f(a, b)
}

func main() {
  a, b := 2, 3
  fmt.Println(Calculate(a, b, add))
  fmt.Println(Calculate(a, b, mul))
}
// 5
// 6
```

如上例子，Calculate 的 f 参数类型为 CalculateType，add 和 mul 函数具有和 CalculateType 函数类型相同的参数和返回值，因此可以将 add 和 mul 函数作为参数传入 Calculate 函数中。

**参考**：[http://objcoding.com/2017/12/27/Go-functions-as-values-and-types/](http://objcoding.com/2017/12/27/Go-functions-as-values-and-types/)

---

## 2. 空接口 interface{}

空接口是接口类型的特殊形式，空接口没有任何方法，因此任何类型都无须实现空接口。从实现的角度看，任何值都满足这个接口的需求。因此空接口类型可以保存任何值，也可以从空接口中取出原值。

**提示**:

空接口类型类似于 C# 或 Java 语言中的 Object、C语言中的 void*、C++ 中的 std::any。在泛型和模板出现前，空接口是一种非常灵活的数据抽象保存和使用的方法。

**参考**：[Go语言空接口类型（interface{}）](http://c.biancheng.net/view/84.html)

---

## 3. 临时对象池sync.Pool

在高并发或者大量的数据请求的场景中，我们会遇到很多问题，垃圾回收就是其中之一（garbage collection），为了减少优化GC，我们一般想到的方法就是能够让对象得以重用。这就需要一个对象池来存储待回收对象，等待下次重用，从而减少对象产生数量。我们可以把sync.Pool类型值看作是存放可被重复使用的值的容器。此类容器是自动伸缩的、高效的，同时也是并发安全的

**案例**:

```go
package main

import(
    "fmt"
    "sync"
)

func main() {
    p := &sync.Pool{
        New: func() interface{} {
            return 0
        },
    }

    a := p.Get().(int)
    p.Put(1)
    b := p.Get().(int)
    fmt.Println(a, b)
```

**参考**：

- [go语言的官方包sync.Pool的实现原理和适用场景](https://blog.csdn.net/yongjian_lian/article/details/42058893)

- [golang的临时对象池sync.Pool](http://www.01happy.com/golang-sync-pool/)

---

## sync.Mutex 和 sync.RWMutex

Mutex：互斥锁

RWMutex：读写锁，RWMutex 基于 Mutex 实现

### Mutex 互斥锁

- Mutex 为互斥锁，Lock() 加锁，Unlock() 解锁

- 在一个 goroutine 获得 Mutex 后，其他 goroutine 只能等到这个 goroutine 释放该 Mutex

- 使用 Lock() 加锁后，不能再继续对其加锁，直到利用 Unlock() 解锁后才能再加锁

- 在 Lock() 之前使用 Unlock() 会导致 panic 异常

- 已经锁定的 Mutex 并不与特定的 goroutine 相关联，这样可以利用一个 goroutine 对其加锁，再利用其他 goroutine 对其解锁

- 在同一个 goroutine 中的 Mutex 解锁之前再次进行加锁，会导致死锁
适用于读写不确定，并且只有一个读或者写的场景

### RWMutex 读写锁

- RWMutex 是单写多读锁，该锁可以加多个读锁或者一个写锁

- 读锁占用的情况下会阻止写，不会阻止读，多个 goroutine 可以同时获取读锁

- 写锁会阻止其他 goroutine（无论读和写）进来，整个锁由该 goroutine 独占

- 适用于读多写少的场景

#### Lock() 和 Unlock()

- Lock() 加写锁，Unlock() 解写锁

- 如果在加写锁之前已经有其他的读锁和写锁，则 Lock() 会阻塞直到该锁可用，为确保该锁可用，已经阻塞的 Lock() 调用会从获得的锁中排除新的读取器，即写锁权限高于读锁，有写
锁时优先进行写锁定

- 在 Lock() 之前使用 Unlock() 会导致 panic 异常

#### RLock() 和 RUnlock()

- RLock() 加读锁，RUnlock() 解读锁

- RLock() 加读锁时，如果存在写锁，则无法加读锁；当只有读锁或者没有锁时，可以加读锁，读锁可以加载多个

- RUnlock() 解读锁，RUnlock() 撤销单词 RLock() 调用，对于其他同时存在的读锁则没有效果

- 在没有读锁的情况下调用 RUnlock() 会导致 panic 错误

- RUnlock() 的个数不得多余 RLock()，否则会导致 panic 错误

**参考**：[golang 中 sync.Mutex 和 sync.RWMutex](https://www.jianshu.com/p/679041bdaa39)

---

## 4. reflect 反射

允许程序操纵对象的值和类型

**参考**：[https://colobu.com/2016/07/09/dive-into-go-13/](https://colobu.com/2016/07/09/dive-into-go-13/)

---

## 5. 函数闭包

Go 语言支持匿名函数，可作为闭包。匿名函数是一个"内联"语句或表达式。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。

以下实例中，我们创建了函数 getSequence() ，返回另外一个函数。该函数的目的是在闭包中递增 i 变量，代码如下：

```go
package main

import "fmt"

func getSequence() func() int {
   i:=0
   return func() int {
      i+=1
     return i  
   }
}

func main(){
   /* nextNumber 为一个函数，函数 i 为 0 */
   nextNumber := getSequence()  

   /* 调用 nextNumber 函数，i 变量自增 1 并返回 */
   fmt.Println(nextNumber())   //输出1
   fmt.Println(nextNumber())   //输出2
   fmt.Println(nextNumber())   //输出3
   
   /* 创建新的函数 nextNumber1，并查看结果 */
   nextNumber1 := getSequence()  
   fmt.Println(nextNumber1())  //输出1
   fmt.Println(nextNumber1())  //输出2
}
```

**参考**：[Go 语言函数闭包](http://www.runoob.com/go/go-function-closures.html)

---

## 6. GoLang中 json、map、struct 之间的相互转化

**参考**：[GoLang中 json、map、struct 之间的相互转化](https://www.cnblogs.com/liang1101/p/6741262.html)

---

## 7. Go语言的接口interface、struct和组合、继承

**参考**：[Go语言的接口interface、struct和组合、继承](https://www.cnblogs.com/pluse/p/7655977.html)

---

## 8. 数组和切片的区别

**golang array 特点**：

- array是固定长度的数组，使用前必须确定数组长度

- golang中的数组是值类型,也就是说，如果你将一个数组赋值给另外一个数组，那么，实际上就是整个数组拷贝了一份

- 如果golang中的数组作为函数的参数，那么实际传递的参数是一份数组的拷贝，而不是数组的指针

- array的长度也是Type的一部分，这样就说明[10]int和[20]int是不一样的。

**slice 类型**:

- slice是一个引用类型，是一个动态的指向数组切片的指针。

- slice是一个不定长的，总是指向底层的数组array的数据结构。

==作为函数参数时，数组传递的是数组的副本，而slice传递的是指针==

### 8.1. 声明方式

#### 8.1.1. 数组

`var variable_name [SIZE] variable_type`

如：`var balance [10] float32`

#### 8.1.2 切片

`var identifier []type`

 `var slice1 []type = make([]type, len)` or `slice1 := make([]type, len)` or `slice1 := make([]T, length, capacity)`

### 8.2. 初始化

#### 8.2.1 数组

`var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}`

`var balance = [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}`

#### 8.2.2. 切片

`s :=[] int {1,2,3 }`

此外，直接从数组或切片中截取获得的对象也是切片，如

```go
var arr =[10]{1,2,3,4,5,6}  
sl := arr[2:5] //创建有3个元素的slice
```

**参考**：

- [goLang slice 和 array区别](https://segmentfault.com/a/1190000013148775)

- [Go 语言数组](https://www.runoob.com/go/go-arrays.html)

- [Go 语言切片(Slice)](https://www.runoob.com/go/go-slice.html)

---

## 9. iota

iota，特殊常量，可以认为是一个可以被编译器修改的常量。

iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。

iota 可以被用作枚举值：

```go
const (
    a = iota
    b = iota
    c = iota
)
```

第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a=0, b=1, c=2 可以简写为如下形式：

```go
const (
    a = iota
    b
    c
)
```

```go
package main

import "fmt"

func main() {
    const (
            a = iota   //0
            b          //1
            c          //2
            d = "ha"   //独立值，iota += 1
            e          //"ha"   iota += 1
            f = 100    //iota +=1
            g          //100  iota +=1
            h = iota   //7,恢复计数
            i          //8
    )
    fmt.Println(a,b,c,d,e,f,g,h,i)
```

以上实例运行结果为：

`0 1 2 ha ha 100 100 7 8`

**参考**：[Go 语言常量](https://www.runoob.com/go/go-constants.html)

---

## 10. time 包

time 包中时间单位有：Nanosecond（纳秒），Microsecond（微秒）,Millisecond（毫秒）,Second,Minute,Hour

对应在 time 包中的定义为：

```go
type Duration int64

const (
	Nanosecond  Duration = 1
	Microsecond          = 1000 * Nanosecond
	Millisecond          = 1000 * Microsecond
	Second               = 1000 * Millisecond
	Minute               = 60 * Second
	Hour                 = 60 * Minute
)
```

**参考**：[golang中time包用法](https://studygolang.com/articles/4331?fr=sidebar)

---

## 11. 精密计算和 big 包

我们知道有些时候通过编程的方式去进行计算是不精确的。如果你使用 Go 语言中的 float64 类型进行浮点运算，返回结果将精确到 15 位，足以满足大多数的任务。当对超出 int64 或者 uint64 类型这样的大数进行计算时，如果对精度没有要求，float32 或者 float64 可以胜任，但如果对精度有严格要求的时候，我们不能使用浮点数，在内存中它们只能被近似的表示。

**参考**：[精密计算和 big 包](https://wiki.jikexueyuan.com/project/the-way-to-go/09.4.html)

---

## 12. new和make的区别

Go语言中new和make是内建的两个函数，主要用来创建分配类型内存

变量的声明我们可以通过var关键字，然后就可以在程序中使用。当我们不指定变量的默认值时，这些变量的默认值是他们的零值，比如int类型的零值是0,string类型的零值是""，引用类型的零值是nil。

make 和 new 不同，它只用于chan、map以及切片的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。

二者都是内存的分配（堆上），但是make只用于slice、map以及channel的初始化（非零值）；而new用于类型的内存分配，并且内存置为零。

make返回的还是这三个引用类型本身；而new返回的是指向类型的指针

**参考**：[Go语言中new和make的区别](https://www.flysnow.org/2017/10/23/go-new-vs-make.html)

---

## 13. 指针

```go
package main

import "fmt"

func swap(a, b *int) {
    b, a = a, b
}

func main() {
    x, y := 1, 2
    swap(&x, &y)
    fmt.Println(x, y)
}
```

`运行结果：1 2`

结果表明，交换是不成功的。上面代码中的 swap() 函数交换的是 a 和 b 的地址，在交换完毕后，a 和 b 的变量值确实被交换。但和 a、b 关联的两个变量并没有实际关联。这就像写有两座房子的卡片放在桌上一字摊开，交换两座房子的卡片后并不会对两座房子有任何影响。

**参考**：[Go语言指针详解，看这一篇文章就够了](http://c.biancheng.net/view/21.html)

---

## 14. channel 详解

Channel是Go中的一个核心类型，你可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯

就像 map 和 slice 数据类型一样, channel必须先创建再使用(箭头的指向就是数据的流向):

```go
ch := make(chan int)
```

```go
chan T          // 可以接收和发送类型为 T 的数据
chan<- float64  // 只可以用来发送 float64 类型的数据
<-chan int      // 只可以用来接收 int 类型的数据
```

**参考**：[Go Channel 详解](https://colobu.com/2016/04/14/Golang-Channels/)

---

## 15. select关键字

select就是用来监听和channel有关的IO操作，当 IO 操作发生时，触发相应的动作。

```go
//select基本用法
select {
case <- chan1:
// 如果chan1成功读到数据，则进行该case处理语句
case chan2 <- 1:
// 如果成功向chan2写入数据，则进行该case处理语句
default:
// 如果上面都没有成功，则进入default处理流程
```

**参考**：

- [select关键字用法](https://studygolang.com/articles/15740)

---

## 16. 空 struct{} 用法

golang 空结构体 struct{} 可以用来节省内存，用来单纯的做控制信息

```go
a := struct{}{}
println(unsafe.Sizeof(a))
// Output: 0
```

两个空结构体的地址相等

```go
var a, b struct{}
fmt.Println(&a == &b) // true
```

==用法 1==：下例说明在map里节省资源的用途：

```go
set := make(map[string]struct{})
for _, value := range []string{"apple", "orange", "apple"} {
   set[value] = struct{}{}
}
fmt.Println(set)
// Output: map[orange:{} apple:{}]
```

==用法 2==：下例，演示了struct{}可以向人展示对象中不需要任何数据，仅包含需要方法。

```go
type Lamp struct{}

func (l Lamp) On() {
        println("On")

}
func (l Lamp) Off() {
        println("Off")
}

func main() {
       	// Case #1.
       	var lamp Lamp
       	lamp.On()
       	lamp.Off()
       	// Output:
       	// on
       	// off
	
       	// Case #2.
       	Lamp{}.On()
       	Lamp{}.Off()
       	// Output: 
       	// on
       	// off
}
```

==用法 3==：使用channel，但并不需要附带任何数据

```go
func worker(ch chan struct{}) {
	// Receive a message from the main program.
	<-ch
	println("roger")
	
	// Send a message to the main program.
	close(ch)
}

func main() {
	ch := make(chan struct{})
	go worker(ch)
	
	// Send a message to a worker.
	ch <- struct{}{}
	
	// Receive a message from the worker.
	<-ch
	println(“roger")
	// Output:
	// roger
	// roger
}
```

**参考**：

- [Golang空结构体struct{}用途，你知晓么?](https://blog.csdn.net/weixin_44328662/article/details/86501900)

- [golang 空结构体struct{}解析](https://blog.csdn.net/a64180190/article/details/76615561)

---

## 17. 三个点 ... 的作用

‘…’ 其实是go的一种语法糖。
它的第一个用法主要是用于函数有多个不定参数的情况，可以接受多个不确定数量的参数。 
第二个用法是slice可以被打散进行传递。

```go
func test1(args ...string) { //可以接受任意个string参数
    for _, v:= range args{
        fmt.Println(v)
    }
}

func main(){
var strss= []string{
        "qwr",
        "234",
        "yui",
        "cvbc",
    }
    test1(strss...) //切片被打散传入
}
//qwr
//234
//yui
//cvbc
```

```go
    var strss= []string{
        "qwr",
        "234",
        "yui",

    }
    var strss2= []string{
        "qqq",
        "aaa",
        "zzz",
        "zzz",
    }
strss=append(strss,strss2...) //strss2的元素被打散一个个append进strss
fmt.Println(strss)
//[qwr 234 yui qqq aaa zzz zzz]
```

如果没有’…’，面对上面的情况，无疑会增加代码量，有了’…’，使代码变得更加简洁

**参考**：[golang中的三个点 '...' 的用法](https://blog.csdn.net/jeffrey11223/article/details/79166724)