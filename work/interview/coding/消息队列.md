# 消息队列

> 消息队列，简称为MQ(Message Queue)

kafka、activemq、rabbitmq、rocketmq 等都是消息队列中间件

在Java里边，已经实现了不少的队列接口：

![image.png](https://ws1.sinaimg.cn/large/006alGmrgy1ga86epm2c5j30hl0b046w.jpg)

那为什么还需要消息队列(MQ)这种**中间件**呢？？？其实这个问题，跟之前学Redis的时候很像。Redis是一个以key-value形式存储的内存数据库，明明我们可以使用类似HashMap这种实现类就可以达到类似的效果了，那还为什么要Redis？

消息队列可以简单理解为：**把要传输的数据放在队列中**。

![image.png](https://ws1.sinaimg.cn/large/006alGmrgy1ga86fjyzsmj308c0cvq57.jpg)

- 把数据放到消息队列叫做**生产者**
- 从消息队列里边取数据叫做**消费者**

### 为什么使用消息队列

异步, 解耦, 削峰.

1. 异步. A系统需要发送个请求给B系统处理,由于B系统需要查询更新数据库花费时间较长,以至于A系统要等待B系统处理完毕后再发送下个请求,造成A系统资源浪费.使用消息队列后,A系统生产完消息后直接丢进消息消息队列,就完成一次请求,继续处理下个请求.
2. 解耦. A系统发送个数据到BCD三个系统，接口调用发送，那如果E系统也要这个数据呢？那如果C系统现在不需要了呢？现在A系统又要发送第二种数据了呢？A系统负责人濒临崩溃中。。。再来点更加崩溃的事儿，A系统要时时刻刻考虑BCDE四个系统如果挂了咋办？我要不要重发？我要不要把消息存起来？使用消息队列就能解决这个问题,A系统只负责生产数据,不需要考虑消息被哪个系统来消费.
3. 削峰. A系统调用B系统处理数据,每天0点到11点，A系统风平浪静，每秒并发请求数量就100个。结果每次一到11点~1点，每秒并发请求数量突然会暴增到1万条。但是B系统最大的处理能力就只能是每秒钟处理1000个请求啊。。。尴尬了，系统会崩掉。。。引入消息队列,把请求数据先存入消息中间件系统中,消费系统慢慢拉取消费.

---

## 消息队列的优缺点

- 点就是异步,解耦 ,削峰.
- 缺点:

1. 系统可用性降低：系统引入的外部依赖越多，越容易挂掉，本来你就是A系统调用BCD三个系统的接口就好了，人ABCD四个系统好好的，没啥问题，你偏加个MQ进来，万一MQ挂了咋整？MQ挂了，整套系统崩溃了，你不就完了么。
2. 系统复杂性提高：硬生生加个MQ进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已
3. 一致性问题：A系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是BCD三个系统那里，BD两个系统写库成功了，结果C系统写库失败了，咋整？你这数据就不一致了。

**参考**：

- [什么是消息队列？](https://blog.csdn.net/yue_2018/article/details/89305275)
- [消息队列](https://www.jianshu.com/p/4ca06c2a5899)