[toc]

# 知识点

## 进程，线程和协程的区别

`进程`：是 “程序执行的一个实例” ，是系统分配资源的实体。进程创建必须分配一个完整的独立地址空间。至少有 5 种基本状态，它们是：初始态，就绪状态，执行态，等待状态，终止状态。

`线程`：是进程的一个执行流，独立执行它自己的程序代码。是操作系统能够进行运算调度的最小单位。.可与同属一个进程的其他的线程共享进程所拥有的全部资源。

**进程和线程的区别**：

1. 拥有资源

    进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。

2. 调度

    线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

3. 系统开销

    由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

4. 通信方面

    线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

`协程`：是轻量级的线程，一个进程可轻松创建数十万计的协程。协程的调度完全由用户控制。

`线程和协程的区别`：

1. 一个线程可以多个协程，一个进程也可以单独拥有多个协程

2. 最大的优势就是协程极高的执行效率。协程切换的开销小于线程切换。

3. go 有自己的协程调度模型；线程则由操作系统内核进行调度

![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1gcpu6w1xv6j314r0t7q96.jpg)

**参考**：

- [每个程序员都会遇到的面试问题：谈谈进程和线程的区别](https://www.cnblogs.com/jobbible/p/9766649.html)

- [【linux操作系统】进程和线程](https://blog.csdn.net/xing1584114471/article/details/92793556)

- [协程与线程的区别](https://blog.csdn.net/fadbgfnbxb/article/details/88787361)

- [进程、线程和协程之间的区别和联系](https://blog.csdn.net/daaikuaichuan/article/details/82951084)

- [协程](https://www.liaoxuefeng.com/wiki/897692888725344/923057403198272)

---

## 进程、线程、协程使用堆栈的区别

- 进程：拥有自己独立的堆和栈，既不共享堆，也不共享栈，进程由操作系统调度；

- 线程：拥有自己独立的栈和共享的堆，共享堆，不共享栈，标准线程由操作系统调度；

- 协程：拥有自己独立的栈和共享的堆，共享堆，不共享栈，协程由程序员在协程的代码里显示调度。

**参考**：[进程、线程、协程使用堆栈的区别](https://segmentfault.com/a/1190000019910391)

---

## 内核态和用户态

操作系统的两种不同 cpu 状态

- 内核态（Kernel Mode）：运行操作系统程序，操作硬件

- 用户态（User Mode）：运行用户程序

**内核态与用户态的区别**：

- 内核态与用户态是操作系统的两种运行级别，当程序运行在3级特权级上时，就可以称之为运行在用户态。因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；当程序运行在0级特权级上时，就可以称之为运行在内核态。

- 运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态（比如操作硬件）。

- 处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的；处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。

**参考**：[用户态和内核态的区别](https://www.cnblogs.com/gizing/p/10925286.html)

---

## 用户空间与内核空间

现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。

---

## 进程生命周期，五种基本状态

![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1gcd4wnu75kj30n80cx41k.jpg)

- 创建状态：进程在创建时需要申请一个空白PCB，向其中填写控制和管理进程的信息，完成资源分配。如果创建工作无法完成，比如资源无法满足，就无法被调度运行，把此时进程所处状态称为创建状态

- 就绪状态：进程已经准备好，已分配到所需资源，只要分配到CPU就能够立即运行

- 执行状态：进程处于就绪状态被调度后，进程进入执行状态

- 阻塞状态：正在执行的进程由于某些事件（I/O请求，申请缓存区失败）而暂时无法运行，进程受到阻塞。在满足请求时进入就绪状态等待系统调用

- 终止状态：进程结束，或出现错误，或被系统终止，进入终止状态。无法再执行

**参考**：[进程的五种基本状态 - 操作系统](https://blog.csdn.net/cafucwxy/article/details/78453430)

---

## 单工，半双工和全双工

![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1gcde6heqdzj30ku06o107.jpg)

**参考**：[单工，半双工和全双工有何区别和联系？](https://zhidao.baidu.com/question/58243700.html)

---

## 进程同步

1. 临界区

2. 信号量

3. 管程

**参考**：[https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.md](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.md)

---

## 经典同步问题

1. 哲学家进餐问题

2. 读者-写者问题

3. 生产者-消费者问题

**参考**：[https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.md](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.md)

---

## 进程通信

1. 管道

    - 只支持半双工通信（单向交替传输）；

    - 只能在父子进程或者兄弟进程中使用。

2. FIFO

    也称为命名管道，去除了管道只能在父子进程中使用的限制。

    FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。

3. 消息队列

4. 信号量

    它是一个计数器，用于为多个进程提供对共享数据对象的访问

5. 共享存储

    允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。

    需要使用信号量用来同步对共享存储的访问。

6. 套接字

    与其它通信机制不同的是，它可用于不同机器间的进程通信。

**参考**：[https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.md](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.md)

---

## 线程间通信方式

- 锁机制：包括互斥锁、条件变量、读写锁

- 信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量

**参考**：[线程通信与进程通信的区别](https://www.cnblogs.com/xh0102/p/5710074.html)

---

## 负载均衡

负载均衡器会根据集群中每个节点的负载情况，将用户请求转发到合适的节点上。

**负载均衡算法**：

- 轮询（Round Robin）

- 加权轮询（Weighted Round Robbin）

- 最少连接（least Connections）

- 加权最少连接（Weighted Least Connection）

- 随机算法（Random）

- 源地址哈希法 (IP Hash)

---

## 程序运行时内存分配的三种方式

- 静态存储区

- 栈区

- 堆区

**参考**：

- [https://blog.csdn.net/qq_35422344/article/details/88093021](https://blog.csdn.net/qq_35422344/article/details/88093021)

- [内存空间分配某面试题](https://blog.csdn.net/weixin_37389821/article/details/83479241)

---

## 堆栈的区别

![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1gckbgg3tb4j30pa0h1gp9.jpg)

1.栈内存存储的是局部变量而堆内存存储的是实体；

2.栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；

3.栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。

**参考**：[Java中堆和栈有什么区别](https://www.php.cn/faq/416802.html)

---

## 文件描述符

Linux 系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行I/O操作的系统调用都会通过文件描述符。

**参考**：[文件描述符（File Descriptor）简介](https://segmentfault.com/a/1190000009724931)

---

## I/O多路复用

通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，pselect，poll，epoll本质上都是同步I/O



下面举一个例子（*参考至链接2*），模拟一个tcp服务器处理30个客户socket。
假设你是一个老师，让30个学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择：

1. 第一种选择：**按顺序逐个检查**，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生卡主，全班都会被耽误。
   这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。
2. 第二种选择：你**创建30个分身**，每个分身检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者线程处理连接。
3. 第三种选择，你**站在讲台上等，谁解答完谁举手**。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。。。 

这种就是IO复用模型，Linux下的select、poll和epoll就是干这个的。将用户socket对应的fd注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作。此时的socket应该采用**非阻塞模式**。
这样，整个过程只在调用select、poll、epoll这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是**事件驱动**，所谓的reactor模式。

**参考**：

- [聊聊IO多路复用之select、poll、epoll详解](https://www.jianshu.com/p/dfd940e7fca2)
- [I/O多路复用技术（multiplexing）是什么](https://www.zhihu.com/question/28594409)

---

## Linux系统5种I/O模型

- 阻塞式 I/O 模型(blocking I/O）
- 非阻塞式 I/O 模型(non-blocking I/O）
- I/O 复用模型(I/O multiplexing）
- 信号驱动式 I/O 模型（signal-driven I/O)
- 异步 I/O 模型（即AIO，全称asynchronous I/O）

**参考**：[Linux系统5种I/O模型](https://www.jianshu.com/p/e0d984d0a5df)

---

## 阻塞、非阻塞、同步、异步

1. 阻塞/非阻塞， 同步/异步的概念要注意讨论的上下文：

   - 在进程通信层面， 阻塞/非阻塞， 同步/异步基本是同义词， 但是需要注意区分讨论的对象是发送方还是接收方。

   - 发送方阻塞/非阻塞（同步/异步）和接收方的阻塞/非阻塞（同步/异步） 是互不影响的。

   - 在 IO 系统调用层面（ IO system call ）层面， **非阻塞 IO 系统调用** 和 **异步 IO 系统调用**存在着一定的差别， 它们都不会阻塞进程， 但是返回结果的方式和内容有所差别， 但是都属于非阻塞系统调用（ non-blocing system call ）

2. 非阻塞系统调用（non-blocking I/O system call 与 asynchronous I/O system call） 的存在可以用来实现线程级别的 I/O 并发， 与通过多进程实现的 I/O 并发相比可以减少内存消耗以及进程切换的开销。

**参考**：[怎样理解阻塞非阻塞与同步异步的区别 - 萧萧回答](https://www.zhihu.com/question/19732473)

---

## 32位操作系统最大支持4G内存

总共2^32^种可能性，2^32^个内存地址，每个内存地址对应1个字节的内容，所以是4G。

Intel 的 32 位 CPU，可使用的地址总线是 36 根（而非 32 根），可寻址的最大内存空间是 2^36 = 64G，可用的地址空间是 4G

所以，这个不是由总线决定的，而是由操作系统限制的。即使 Windows 系统，通过 PAE 完全可以使用超过 4G 的 RAM，至于为什么默认被禁用，主要原因还是 Windows 需要兼容以前的版本，尤其是驱动程序。

**参考**：[关于32位操作系统最大能支持4G内存的问题](https://segmentfault.com/q/1010000015469977)

---

## 死锁条件，如何避免

死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。

**死锁的四个必要条件**：

- 互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。

- 请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。

- 不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。

- 循环等待条件: 若干进程间形成首尾相接循环等待资源的关系

这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。

**死锁避免的基本思想**：系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，如果分配后系统可能发生死锁，则不予分配，否则予以分配，这是一种保证系统不进入死锁状态的动态策略。

**参考**：[死锁的四个必要条件？如何避免与预防死锁？](https://www.cnblogs.com/bopo/p/9228834.html)

---

## 文件系统

文件系统是基于操作系统，用来管理和组织保存在磁盘驱动器上的数据的系统软件，它通过对数据存储布局、空间管理、文件命名和安全控制等方面的管理，解决了如何在上有效地存储数据的问题，可以说通过文件系统，实现了数据的完整性，也就是保证了写入磁盘的数据和随后读出的数据的一致性，同时也实现了数据读写的简单化和安全性。

**参考**：[文件系统的详细介绍](https://baijiahao.baidu.com/s?id=1645179776471092229&wfr=spider&for=pc)

---

## 实时操作系统和分时操作系统的区别

**分时操作系统**：也就是当时计算机比较昂贵，所以一台机子有多个用户来用，但又让人感觉彼此独立，互不影响。

多路性、交互性、独立性、及时性

**实时操作系统**： 以时间为参考，对收到的信号做出“及时”实时“的反应”。

多路性、交互性、独立性、及时性、可靠性

**区别**：

- 及时性：实时系统要求的更及时，达到毫秒级单位

- 实时系统多了可靠性：要求实时系统要求系统高度可靠，武器 飞机 导弹巡航，一个不注意几百万美金就没了，所以要实时采集数据

==实习操作系统“就是反馈时间确定、可控！”==

**参考**：[实时操作系统与分时操作系统的主要区别？](https://www.zhihu.com/question/31609663)

---

## 磁盘调度算法

- 先来先服务：按照磁盘请求的顺序进行调度。

- 最短寻道时间优先：优先调度与当前磁头所在磁道距离最近的磁道。

- 电梯算法：电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。

    电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。

**参考**：[磁盘结构](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md)

---

## 孤儿进程和僵尸进程

孤儿进程、僵尸进程

**孤儿进程**：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

**僵尸进程**：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。

**僵尸进程危害**：如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。

**已经产生的僵尸进程，解决方法**：kill掉父进程，它产生的僵尸进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源。

**参考**：[孤儿进程与僵尸进程详解](https://www.jianshu.com/p/c0d224fd925b)

---

## 同一进程中的线程共享哪些资源

**参考**：[同一进程中的线程究竟共享哪些资源](https://blog.csdn.net/shuilan0066/article/details/7683315)

---

## 进程切换和线程切换

**参考**：[进程切换与线程切换的区别？](https://blog.csdn.net/github_37382319/article/details/97273713)

---

## load average

linux系统中的==Load==对当前CPU工作量的度量。简单的说是进程队列的长度。

Load Average 就是一段时间 (1 分钟、5分钟、15分钟) 内平均 Load 。

可以通过系统命令“top”和“w”来查看当前 load average 情况

**参考**：[Linux系统中的load average](https://www.cnblogs.com/kaituorensheng/p/3602805.html)

---

## 中断

**分类**：

- 同步中断：由程序指令在 cpu 中产生（软件产生）
- 异步中断：硬件设备依照 CPU 时钟信号随机产生，即意味着中断能够在指令之间发生，例如键盘中断。

根据 Intel 官方资料，*同步中断称为异常*（exception），*异步中断被称为中断*（interrupt）。

异常可分为*故障（fault）、陷阱（trap）、终止（abort）*三类。

![image-20200802105240464](https://i.loli.net/2020/08/02/39O8lCvh4aMEUjJ.png)

**参考**：[操作系统中断机制](https://www.jianshu.com/p/4efd858c6520)

---

## 软中断和硬中断

**硬中断**：外围硬件发给CPU或者内存的异步信号就称之为硬中断

*案例*：当网卡接收流入网络的数据包时，需要通知内核数据包到了，网卡需要立即完成这件事，从而优化网络的吞吐量和传输周期，以避免超时。因此网卡立即发出中断，通知内核这里有最新的数据包。内核通过执行网卡已注册的中断处理程序作出应答。中断开始运行，应答硬件，复制最新的网络数据包到内存，然后读取网卡更多的数据包，这些都是重要的、紧迫的、又与硬件相关的的工作。

**软中断**：由软件系统本身发给操作系统内核的中断信号，称之为软中断。*通常是由硬中断处理程序或进程调度程序对操作系统内核的中断*，也就是我们常说的系统调用(System Call)

 **硬中断与软中断之区别与联系？**：

- 硬中断是有外设硬件发出的，需要有中断控制器之参与。其过程是外设侦测到变化，告知中断控制器，中断控制器通过CPU或内存的中断脚通知CPU，然后硬件进行程序计数器及堆栈寄存器之现场保存工作（引发上下文切换），并根据中断向量调用硬中断处理程序进行中断处理
- 软中断则通常是由硬中断处理程序或者进程调度程序等软件程序发出的中断信号，无需中断控制器之参与，直接以一个CPU指令之形式指示CPU进行程序计数器及堆栈寄存器之现场保存工作(亦会引发上下文切换)，并调用相应的软中断处理程序进行中断处理(即我们通常所言之系统调用)
- 硬中断直接以硬件的方式引发，处理速度快。软中断以软件指令之方式适合于对响应速度要求不是特别严格的场景
- 硬中断通过设置CPU的屏蔽位可进行屏蔽，软中断则由于是指令之方式给出，不能屏蔽
- 硬中断发生后，通常会在硬中断处理程序中调用一个软中断来进行后续工作的处理
- 硬中断和软中断均会引起上下文切换(进程/线程之切换)，进程切换的过程是差不多的

**参考**：[CPU中断控制](https://www.ikuai8.com/zhic/ymgn/lyym/xtsz/2020-07-31-07-00-43/cpu.html)

---

## 删除大文件之后，磁盘空间未发生变化

磁盘满了，删掉占用磁盘的大文件之后，磁盘空间未释放、依旧占满：

*未释放磁盘空间原因*：

在Linux或者Unix系统中，通过rm或者文件管理器删除文件将会从文件系统的目录结构上解除链接(unlink).然而如果文件是被打开的（有一个进程正在使用），那么进程将仍然可以读取该文件，磁盘空间也一直被占用。而我删除的是oracle的告警log文件删除的时候文件应该正在被使用

*解决方法*:

首先获得一个已经被删除但是仍然被应用程序占用的文件列表，如下所示：
*[root@ticketb ~]# lsof |grep deleted*

```shell
oracle    12639  oracle    5w      REG              253,0         648     215907 /home/oracle/admin/dbticb/udump/dbticb_ora_12637.trc (deleted)
oracle    12639  oracle    6w      REG              253,0 16749822091     215748 /home/oracle/admin/dbticb/bdump/alert_dbticb.log (deleted)
oracle    12639  oracle    7u      REG              253,0           0      36282 /home/oracle/oracle/product/10.2.0/db_1/dbs/lkinstdbticb (deleted)
oracle    12639  oracle    8w      REG              253,0 16749822091     215748 /home/oracle/admin/dbticb/bdump/alert_dbticb.log (deleted)
oracle    12641  oracle    5w      REG              253,0         648     215907 /home/oracle/admin/dbticb/udump/dbticb_ora_12637.trc (deleted)
oracle    12641  oracle    6w      REG              253,0 16749822091     215748 /home/oracle/admin/dbticb/bdump/alert_dbticb.log (deleted)
```

获取到进程号之后就用 kill 干掉它

*也可以重启*

**参考**：[linux删除文件后没有释放空间](https://blog.csdn.net/wyzxg/article/details/4971843)

---

## CPU 特权等级

*使用 CPU 的权限等级*。如Intel的CPU将特权级别分为4个级别：RING0,RING1,RING2,RING3。Windows只使用其中的两个级别RING0和RING3，RING0只给操作系统用，RING3谁都能用。如果普通应用程序企图执行RING0指令，则Windows会显示“非法指令”错误信息。

ring0是指CPU的运行级别，ring0是最高级别，ring1次之，ring2更次之…… 拿Linux+x86来说， 操作系统（内核）的代码运行在最高运行级别ring0上，可以使用特权指令，控制中断、修改页表、访问设备等等。 应用程序的代码运行在最低运行级别上ring3上，不能做受控操作。如果要做，比如要访问磁盘，写文件，那就要通过执行系统调用（函数），执行系统调用的时候，CPU的运行级别会发生从ring3到ring0的切换，并跳转到系统调用对应的内核代码位置执行，这样内核就为你完成了设备访问，完成之后再从ring0返回ring3。这个过程也称作用户态和内核态的切换

**参考**：[cpu 权限等级是怎么划分的？](https://www.zhihu.com/question/386541262)

---