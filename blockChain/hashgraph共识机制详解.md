# hashgraph共识机制详解

==最好还是直接参考第一篇博文==

Hashgraph 是一种数据结构和共识算法。Hashgraph 不是数字货币，也不是区块链（因为它其实是 DAG 图，并非是链式结构），严格说也不单单是协议。Hashgraph 更像是一个底层的出块层而非一个完整的系统。Hashgraph 能为分布式 APP 提供高效、公平、安全的基础设施。高吞吐量和异步拜占庭容错（ ABFT ）的特点，使得 Hashgraph 在公链和私有链领域都有潜在的使用价值，并且，在保证去中心化的同时不需要繁重的工作量证明。

Hashgraph用的是gossip protocol，原理简单说来就是消息像八卦一样告诉自己的邻居，邻居再告诉他的邻居，这样一直广播出去，直到全网都知道这个消息。

- Hashgraph中的每个节点都可以将新创建的交易和从其他人那里接收到的交易的签名信息（event）传播给其他随机选择的邻居。（如何定义邻居呢？）

- 这些邻居将收到的事件与从其他节点收到的信息聚合成一个新事件，然后将其发送给其他随机选择的邻居。

- 这个过程一直持续到所有节点都知道在开始时创建或接收的信息。

由于八卦协议的快速收敛性，每条新信息都可以快速到达网络中的每个节点。

gossip protocol的传播历史可以通过有向图来说明，每个节点维护一个图，表示每次交易的转发者/证人序列。

Hashgraph假设：不到1/3的节点是拜占庭节点（作弊节点，延迟节点，丢消息节点）

如何确认交易呢：每个节点可以根据是否有超过全网2/3的节点（也就是目击者）来确定交易是否有效。

FLP不可能定理：在网络可靠且存在节点失效的异步分布式系统中，不存在一个可以解决一致性问题的确定性算法。

在异步系统中，即使在仅有一个故障节点的简单情况下，不可能存在确定性的共识协议。

PBFT（实用拜占庭容错）大大优化了消息传播的复杂度（节点通信基本都是同步的），但是实际使用中差不多也就支持到100个节点就是极限了，因此BFT算法只适用于非公链场景。

Hashgraph对共识定义做了一些放宽，本来应该在有限轮通信之后，会取得共识，Hashgraph是在极小概率下共识算法可能会无线执行，但这一概率几乎为0.

Hashgraph的共识算法是非确定性的，但那是能保证最终确定性，同时因为所有节点都是对等节点，避免了潜在的DDOS攻击风险。

## 谣言协议 （Gossip about Gossip）

Gossip 简单来说就是，节点随机选择一个可以连接的邻节点，向其发送一条信息（Event）。而 Gossip about Gossip 则是，收到 gossip 信息的节点，对该 gossip 信息进行签名，并且再把该签名打包进一个新的信息中，并随机发送给网络中的任一节点。这样，每个节点发出的 Gossip 信息都包含了对其收到的前一个 Gossip 信息的签名验证，实际上就是做了一个见证（Witness）工作。

注意这里的 Gossip 过程是非常简单的，收到 Event 信息的节点可以向任意一个或多个节点继续 Gossip 新的 Event。每一次 Gossip 都是对前一次信息的背书和见证。

![image.png](https://ws1.sinaimg.cn/large/006alGmrly1g9f85d5nhrj30gh0eigo5.jpg)

## 虚拟投票（Virtual Voting）

- 事件（event）
    这个很好理解，就好比区块链中的区块，event是一个包含有两个哈希指针的数据结构，并且可以包括0个或若干交易信息，节点在创建event的同时会加上timestamp并且对整个event数字签名。

    ![image.png](https://ws1.sinaimg.cn/large/006alGmrly1g9f86g80gvj30fl0d0dit.jpg)

- 绝对多数（supermajority）
    超过2/3以上节点的数量。

- 可见（seeing）
    当事件 B 可以沿着哈希指针找到事件 A，那么事件 B 就可见事件 A。两个event能通过哈希指针找到。

- 强可见（strongly seeing）
    当事件 B 能找到事件 A 的所有路径中跨越了 `绝对多数` 的 `节点`，那么事件 B 强可见事件 A。白皮书中提到经过数学论证可以保证两个强可见的节点在虚拟投票时能获得一致的结果。简单理解就是事件A和B的发生次序（order）得到了全网节点的共识。

- 轮次（round）
    在 Hashgraph 中，根据事件所处的可见状态，把他们分为不同的轮次（Round）。
    当一个事件强可见绝对多数节点上的先前事件时，我们就说该事件在一个新的轮次上，记为 R。
    ![image.png](https://ws1.sinaimg.cn/large/006alGmrly1g9f9lutmwhj30of0jz46r.jpg)

- 创建轮次（round created）
    所谓的创建轮（Creation Round），就是当一个事件被创建时，它所在的轮次。通常，一个事件被创建时，它会被立即赋予一个轮次号，跟其父事件是在同一个轮次一样。也就是说，如果同节点的父事件是 R 轮，那该事件被创建时也是在第 R 轮，它的创建轮就是 R 轮。

    比如，下图中，初始（Genisis）情况下，所有节点的状态都是相同的，把当前状态定义为第 R 轮，并且 R = 1。后续创建的事件都是在第 R 轮的。
    ![image.png](https://ws1.sinaimg.cn/large/006alGmrly1g9f9lutmwhj30of0jz46r.jpg)

- 接收轮（Receive Round）
    接收轮（Receive Round）很好理解，就是当某个事件强可见超过 2/3 节点的本轮或者上一轮的事件时，这个事件就达到了一个新的轮次，这个轮次就是他的接收轮。如下图：
    ![image.png](https://ws1.sinaimg.cn/large/006alGmrly1g9f9tydkgcj30nb0gnwo1.jpg)
    从上图中，我们可以看到，当 a5 和 d5 被创建时，它们的创建轮是第 R 轮，而当它们能够强可见绝对多数节点的第 R 轮的见证人事件（即 a1, b1, c1, d1）时，它的接收轮就变为 R + 1 轮，也就是说，a5 和 d5 都变成 R + 1 轮的事件了，并且，在它们之后创建的子孙事件都在 R + 1 轮。
    这里需要注意的是：如果事件 a5 只能强可见 R 轮某节点的见证人时，a5 的轮次是不会增加的，依然为此在 R 轮。只有当其强可见绝对多数节点的第 R 轮的见证人，它的轮次才变为 R + 1 轮。

- 见证人（witness）
    每个节点在每个轮次中创建的第一个event就是见证人事件，即该轮次的祖先event，节点可能在某个轮次中没有见证人事件

- 知名见证人（famous witness）
    知名见证人（Famous Witness），当 R 轮的见证人事件被 R + 1 轮的多数（超过 2/3）见证人强可见时，它就是知名见证人事件。
    ![image.png](https://ws1.sinaimg.cn/large/006alGmrly1g9f9wpo9o3j30mi0kaqbl.jpg)

> 我们注意到这里暗含了一个强约束条件，就是 R + 1 轮的见证人事件，这意味着 [a5, b5, c5, d5] 这几个事件必然是强可见大部分节点的第 R 轮见证人事件的，但不必然强可见 c1（比如他们都强可见 [a1, b1, d1, e1] 这 4 个见证人事件。所以，要判断 c1 是否是知名见证人，就必须要求 R + 1 轮的大部分事件都强可见 c1，一旦满足，说明 c1 就是知名见证人了，知名见证人意味着不可更改，这时候系统就可以对该事件进行 commit。

**参考**：

- [理解 Hashgraph](https://www.jianshu.com/p/3c38eaed1349)

- [最通俗易懂讲解Hashgraph](https://www.jianshu.com/p/9f181cefba8d?from=timeline)

- [HASHGRAPH 共识算法详解](https://blog.csdn.net/sinat_34070003/article/details/80536121)

- [Hashgraph算法学习](https://www.jianshu.com/p/e0a6083c84bc)
