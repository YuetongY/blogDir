# 丁博老师 第5章 Part2:原理 第三讲:面向对象的分布式计算环境

## 1. 概念内涵

### 1.1 面向对象程序设计

设计类及由类构作程序程序的方法和过程,用计算机对象
模拟现实世界对象
...综合了功能抽象和数据抽象,对象是数据和操作的封装

### 1.2 面向对象的分布计算环境

支持面向对象的客户-服务器模式的分布式应用,其中服务器应用以对象的形式定义,客户可以以类似于访问本地对象的方式访问异地服务器上的对象。

### 1.3 三大技术体系

- CORBA

- java ee

- .net

### 1.4 实例1:微软技术体系变迁

1. .NET框架是致力于敏捷软件开发、快速应用开发、平台无关性和网络透明化的软件框架
2. COM+是.NET技术的一部份
3. NET 使用分布式计算模型并基于开放标准(如XML)将PC与其他智能设备连接在一起

### 1.5 实例2:OMG技术体系变迁

- OMG:Object Management Group
    1. 1989年成立,分布对象技术的重要推动者和标准的制定者
    2. 制定了软件工程和分布计算领域具有深远影响的一系列规范
    3. 223项,包括CORBA、CCM、DDS、UML等
    4. 在模型驱动开发、工业物联网等领域十分活跃

- CORBA Common Object Request Broker Architecture
    1. OMG组织制定的解决异构环境下分布对象之间互操作问题的分布对象中间件规范
    2. 开发商遵循该规范开发的中间件被称为CORBA中间件
    3. 提供了跨编程语言、跨平台、跨开发商的互操作能力
    4. 以标准化的对象请求代理作为软总线将连接由CORBA对象表达的分布式应用
    5. 通过目录服务、事务处理服务和安全服务等基础服务设施进一步支持高可靠和高可伸缩系统的开发、运行、管理与集成

## 2. 基本原理

### 2.1 基本设计挑战

- 分布性

    分布性是所有面向对象分布计算环境要应对的挑战

- 异构性

    异构性是大部份面向对象分布计算环境要应对的挑战

- 挑战1： 如何标识对象?
    1. 本地对象
        - 指针/引用，如C++指针
    2. 远程对象
        - C++指针只是同一进程空间内部概念
        - 没有机器信息和进程信息（即套接字地址）
        - 分布环境下的对象完整标识:IP地址 + 端口号 + 对象的本地标识

- 挑战2： 如何保持客户方调用方式不变?
    1. “象调用本地对象一样调用远程对象”
    2. 本地对象
        - 拿到对象指针并调用其上方法
    3. 远程对象
        - 拿到远程对象的“指针”，而后调用其上的方法
        - 这个对象指针不可能是真正远程对象的指针，而是本地的一个“替身”

- 挑战3： 如何实现“控制流←→数据流”转换？
    1. 本地对象
        - 由编译器透明地将控制流（即调用对象方法的指令）翻译为机器代码。
    2. 远程对象
        - 调用必须经历一个“控制流→数据流→控制流”的过程
        ![2](http://ww1.sinaimg.cn/large/006alGmrly1g4o6msq80ij313j05y751.jpg)

- 挑战4： 如何在服务方定位要调用的对象和方法？
    1. 本地对象
        - 由编译器、运行环境（如Java虚拟机）等完成方法定位
    2. 远程调用
        - 只能由计算环境根据对象标识进行定位

- 挑战5： 如何设计一个平台无关的通信协议？
    1. 本地对象不涉及
    2. 远程对象
        - 消息的编码必须遵循一个共同格式，不能是A机发了个方法调用请求， B机理解成是返回值！
        - 各种参数和返回值数据类型的编码必须遵循一个共同的格式

- 挑战6：如何支持不同的编程语言？
    1. 本地对象不涉及
    2. 远程对象
        - 每种语言都其有表示对象接口的方式：如Java中的interface和C++中的abstract class
        - 不同机器上的对象如何理解其它机器上对象的接口

### 2.2 CORBA之道一瞥

- 屏蔽分布性
    1. 如何标识对象? 对象引用
    2. 如何保持客户方调用方式不变? Stub
    3. 如何实现“控制流←→数据流”转换？ ORB对象请求代理
    4. 如何在在服务端定位要调用的对象及其方法？
    5. 对象定位
        - POA可移植对象适配器
        - 方法定位 Skeleton
- 屏蔽异构性
    1. 如何设计一个平台无关的通信协议？ GIOP协议
    2. 如何支持不同的编程语言？ CORBA IDL接口定义语言

#### 2.2.1 对象引用

- 对于应用程序员而言，对象引用唯一的表示了分布式环
境下的一个对象实例
    1. 获取方式：静态约定、动态获取
    2. 应用程序员无需关注对象引用内部如何组织
- 对于中间件设计者而言，对象引用是对象定位管理基础
    1. 对象引用内部至少应当包含
        - 如何定位对象所在机器（如IP地址）
        - 如何在该机器上定位对象所在进程（如端口号）
        - 如何在该进程中定位目标对象（如Object Key）

#### 2.2.2 IDL及Stub/Skeleton

- 在CORBA标准中定义了OMG IDL（Interface
Definition Language）来描述对象访问接口
    1. IDL描述服务方对外提供、客户方可以访问的接口

- IDL的作用
    1. 实现了对象接口与对象实现的分离
    2. 屏蔽了语言和系统软件带来的异构性
    3. 是自动生成对象Stub和Skeleton的依据
        - OMG定义了IDL到主流程序设计语言的映射

- Stub和Skeleton均是接口相关的
    1. 每个CORBA对象均有根据其IDL生成的Stub和Skeleton
    2. 接口的一致性是Stub能够成为远程对象的“本地替身”的前提
    3. Skeleton主要负责接口中方法的适配

#### 2.2.3 POA可移植对象适配器

- 远程过程调用中“适配器”的面向对象扩展
    1. 对象实现（Servant）的生命周期管理
    2. Servant与对象请求代理之间的纽带，实现对象和方法的定位

- POA在内部实现上维护了一个所管理的Servant列表
    1. 对象适配实际上就是根据对象引用查表的过程

#### 2.2.4 GIOP协议

- GIOP（Gerneral Inter-ORB Protocol）
    1. 定义了ORB发送和接收的各种消息的格式及其含义
    2. 定义了各种数据类型如何进行编码（CDR）
    3. 允许不同厂商生产的ORB之间进行互操作

- GIOP并不是可直接用于ORB之间进行通信的具体协议
    1. 可以被看作一个额外的抽象层，适用于所有面向连接的网络协议
    2. IIOP协议则是GIOP在TCP/IP协议上的一个具体映射

### 2.3 典型的CORBA应用模式

- 客户/服务器模式
    1. Client应用：向Server发出请求，请求Server中的某个对象执行某
个操作
        - 客户端调用者可以是对象，也可以是普通的C++程序
    2. Server应用：包括一个或多个对象实现

- CORBA通过ORB（Object Request Broker）来屏蔽分布性和异构性


