# 丁博老师 第5章 Part2:原理 第三讲:面向对象的分布式计算环境

## 1. 概念内涵

### 1.1 面向对象程序设计

设计类及由类构作程序程序的方法和过程,用计算机对象
模拟现实世界对象
...综合了功能抽象和数据抽象,对象是数据和操作的封装

### 1.2 面向对象的分布计算环境

支持面向对象的客户-服务器模式的分布式应用,其中服务器应用以对象的形式定义,客户可以以类似于访问本地对象的方式访问异地服务器上的对象。

### 1.3 三大技术体系

- CORBA

- java ee

- .net

### 1.4 实例1:微软技术体系变迁

1. .NET框架是致力于敏捷软件开发、快速应用开发、平台无关性和网络透明化的软件框架
2. COM+是.NET技术的一部份
3. NET 使用分布式计算模型并基于开放标准(如XML)将PC与其他智能设备连接在一起

### 1.5 实例2:OMG技术体系变迁

- OMG:Object Management Group
    1. 1989年成立,分布对象技术的重要推动者和标准的制定者
    2. 制定了软件工程和分布计算领域具有深远影响的一系列规范
    3. 223项,包括CORBA、CCM、DDS、UML等
    4. 在模型驱动开发、工业物联网等领域十分活跃

- CORBA Common Object Request Broker Architecture
    1. OMG组织制定的解决异构环境下分布对象之间互操作问题的分布对象中间件规范
    2. 开发商遵循该规范开发的中间件被称为CORBA中间件
    3. 提供了跨编程语言、跨平台、跨开发商的互操作能力
    4. 以标准化的对象请求代理作为软总线将连接由CORBA对象表达的分布式应用
    5. 通过目录服务、事务处理服务和安全服务等基础服务设施进一步支持高可靠和高可伸缩系统的开发、运行、管理与集成

## 2. 基本原理

### 2.1 基本设计挑战

- 分布性

    分布性是所有面向对象分布计算环境要应对的挑战

- 异构性

    异构性是大部份面向对象分布计算环境要应对的挑战

- 挑战1： 如何标识对象?
    1. 本地对象
        - 指针/引用，如C++指针
    2. 远程对象
        - C++指针只是同一进程空间内部概念
        - 没有机器信息和进程信息（即套接字地址）
        - 分布环境下的对象完整标识:IP地址 + 端口号 + 对象的本地标识

- 挑战2： 如何保持客户方调用方式不变?
    1. “象调用本地对象一样调用远程对象”
    2. 本地对象
        - 拿到对象指针并调用其上方法
    3. 远程对象
        - 拿到远程对象的“指针”，而后调用其上的方法
        - 这个对象指针不可能是真正远程对象的指针，而是本地的一个“替身”

- 挑战3： 如何实现“控制流←→数据流”转换？
    1. 本地对象
        - 由编译器透明地将控制流（即调用对象方法的指令）翻译为机器代码。
    2. 远程对象
        - 调用必须经历一个“控制流→数据流→控制流”的过程
        ![2](http://ww1.sinaimg.cn/large/006alGmrly1g4o6msq80ij313j05y751.jpg)

- 挑战4： 如何在服务方定位要调用的对象和方法？
    1. 本地对象
        - 由编译器、运行环境（如Java虚拟机）等完成方法定位
    2. 远程调用
        - 只能由计算环境根据对象标识进行定位

- 挑战5： 如何设计一个平台无关的通信协议？
    1. 本地对象不涉及
    2. 远程对象
        - 消息的编码必须遵循一个共同格式，不能是A机发了个方法调用请求， B机理解成是返回值！
        - 各种参数和返回值数据类型的编码必须遵循一个共同的格式

- 挑战6：如何支持不同的编程语言？
    1. 本地对象不涉及
    2. 远程对象
        - 每种语言都其有表示对象接口的方式：如Java中的interface和C++中的abstract class
        - 不同机器上的对象如何理解其它机器上对象的接口

### 2.2 CORBA之道一瞥

- 屏蔽分布性
    1. 如何标识对象? 对象引用
    2. 如何保持客户方调用方式不变? Stub
    3. 如何实现“控制流←→数据流”转换？ ORB对象请求代理
    4. 如何在在服务端定位要调用的对象及其方法？
    5. 对象定位
        - POA可移植对象适配器
        - 方法定位 Skeleton
- 屏蔽异构性
    1. 如何设计一个平台无关的通信协议？ GIOP协议
    2. 如何支持不同的编程语言？ CORBA IDL接口定义语言

#### 2.2.1 对象引用

- 对于应用程序员而言，对象引用唯一的表示了分布式环
境下的一个对象实例
    1. 获取方式：静态约定、动态获取
    2. 应用程序员无需关注对象引用内部如何组织
- 对于中间件设计者而言，对象引用是对象定位管理基础
    1. 对象引用内部至少应当包含
        - 如何定位对象所在机器（如IP地址）
        - 如何在该机器上定位对象所在进程（如端口号）
        - 如何在该进程中定位目标对象（如Object Key）

#### 2.2.2 IDL及Stub/Skeleton

- 在CORBA标准中定义了OMG IDL（Interface
Definition Language）来描述对象访问接口
    1. IDL描述服务方对外提供、客户方可以访问的接口

- IDL的作用
    1. 实现了对象接口与对象实现的分离
    2. 屏蔽了语言和系统软件带来的异构性
    3. 是自动生成对象Stub和Skeleton的依据
        - OMG定义了IDL到主流程序设计语言的映射

- Stub和Skeleton均是接口相关的
    1. 每个CORBA对象均有根据其IDL生成的Stub和Skeleton
    2. 接口的一致性是Stub能够成为远程对象的“本地替身”的前提
    3. Skeleton主要负责接口中方法的适配

#### 2.2.3 POA 可移植对象适配器

- 远程过程调用中“适配器”的面向对象扩展
    1. 对象实现（Servant）的生命周期管理
    2. Servant与对象请求代理之间的纽带，实现对象和方法的定位

- POA在内部实现上维护了一个所管理的Servant列表
    1. 对象适配实际上就是根据对象引用查表的过程

#### 2.2.4 GIOP协议

- GIOP（Gerneral Inter-ORB Protocol）
    1. 定义了ORB发送和接收的各种消息的格式及其含义
    2. 定义了各种数据类型如何进行编码（CDR）
    3. 允许不同厂商生产的ORB之间进行互操作

- GIOP并不是可直接用于ORB之间进行通信的具体协议
    1. 可以被看作一个额外的抽象层，从而获得可缩放性、灵活性和架构中立性等益处
    2. 适用于所有面向连接的网络协议
    3. IIOP协议则是GIOP在TCP/IP协议上的一个具体映射

### 2.3 典型的CORBA应用模式

- 客户/服务器模式
    1. Client应用：向Server发出请求，请求Server中的某个对象执行某
个操作
        - 客户端调用者可以是对象，也可以是普通的C++程序
    2. Server应用：包括一个或多个对象实现

- CORBA通过ORB（Object Request Broker）来屏蔽分布性和异构性

## 3. 设计进阶

### 3.1 应对并发请求

- 衡量并发的指标
    1. 吞吐量(单位时间内请求数量)、在线/并发用户数

- 分布式系统的解决方案
    1. 重直扩展
        - 提升单机处理能力
        - 硬件或架构优化
    2. 水平扩展
        - 增加服务器数量

#### 3.1.1 CORBA服务端请求分发原理

- POA管理对象引用、对象ID以及Servants之间的关系;负责对象
引用、对象ID以及Sevants之间的映射
- 一个ORB中可以创建多个POA,在不同POA上加载不同对象周期
管理、请求派发方法、线程并发模型等,从而应对不同的请求
- 多个POA按层次的方式进行组织

#### 3.1.2 通信级并发模型

- 阻塞模型、响应式模型和线程模型
    1. 体现在如何接收数据上(发送由应用代码控制)

#### 3.1.3 服务端通信级+请求级并发

![2](http://ww1.sinaimg.cn/large/006alGmrgy1g4onc75yz8j316a0qzthx.jpg)

### 3.2 不可控的网络环境

- 不可控的网络环境
    1. 网络可能丢包、连接可能异常断开、对方可能死机...
    2. 导致远程调用面临一系列挑战
        - 案例:消息传递的三种主义：至多一次(At most once)、至少一次(At least once)、精确一次(Exactly once)

- 通过ORB策略/属性来应对开放网络环境

![2](http://ww1.sinaimg.cn/large/006alGmrgy1g4onev5z6rj31640dvtct.jpg)

### 3.3 应对应用自身的开放性

#### 3.3.1 传输设计时未知的数据类型

- 使用Any类型
    1. Any 是IDL中一种基本类型,可被作一个容器
        - 可以封装任何类型,允许用户发送和接收一个在编译时类型不固定的值

#### 3.3.2 如何调用设计时未知的请求

## 4. 案例剖析

### 4.1 GIOP/IIOP协议

#### 4.1.1

- 传输假设(6个)
    1. GIOP对执行GIOP协议实现的底层传输作了大量的假设。
- 公共数据表示(CDR, Common Data Representation)
    1. GIOP为每个IDL数据类型定义了一个连在一起的格式,使得始发者和接收者在数据的二进制布局中完全一致。
- 消息格式
    1. GIOP定义了由客户机和服务器通信使用的8种消息类型
    2. 有两种是实现CORBA的基本的远程方法激活语义所必须的
    3. 其余的是控制消息或支持某种优化的消息。

#### 4.1.2 公共数据表示

- CDR编码是一种注重效率的折中方案
    1. CDR同时支持大端和小端表示
        - 如果始发方和接收方使用不同的字节类型,接收方负责字节变换。这个模型,也称接收方更正模型(receiver makes it right)
- CDR按照自然边界对齐原始数据类型
    1. 数据通过存储在内存中数据的指针编组或解组成它的自然二进制表示。要由一些字节流部分填充
- CDR编码的数据是非自识别的
    1. CDR编码需要在始发方和接收方之间有一个关于要交换的数据类型约定

#### 4.1.3 GIOP: IOR

- IOR:Interoperable Object Reference
- 含有足够的信息可以与任何类型的 ORB 中的对象通
信,这些信息包括:
    1. 目标对象的类型
    2. 主机的 Internet 地址
    3. 主机的端口号
    4. Object key (在 server 中是唯一的 ORB 特定数据)

### 4.2 ICE(Internet Communication Engine)

- CORBA相比
    1. 更简洁
        - 没有标准规范符合性的拖累
    2. 更完备
        - IceGrid负载均衡/容错、IcePatch远程部署、Glacier防火墙穿透
    3. 更安全
        - 真正能运作的SSL实现的安全的防火墙
    4. 更实用
        - 真正可用的产品,而非各类理想特性的堆砌
    5. 更普适
        - 适用于嵌入式设备到服务器,提供现代语言映射和操作系统支持
