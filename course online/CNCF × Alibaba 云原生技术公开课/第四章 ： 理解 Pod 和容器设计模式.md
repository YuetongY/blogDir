# 第四章 ： 理解 Pod 和容器设计模式

**容器的本质**：一个视图被隔离、资源受限的进程

    - 容器里 PID = 1 的进程就是应用本身

        - 管理虚拟机 = 管理基础设施；管理容器 = 直接管理应用本身

**Kebernetes**：云时代的操作系统

    - 容器镜像其实就是：这个操作系统的软件安装包

pod 和 container 之间的关系可以类比为进程组和进程之间的关系

**超亲密关系**：

1. 比如说两个进程之间会发生文件交换，前面提到的例子就是这样，一个写日志，一个读日志；

2. 两个进程之间需要通过 localhost 或者说是本地的 Socket 去进行通信，这种本地通信也是超亲密关系；

3. 这两个容器或者是微服务之间，需要发生非常频繁的 RPC 调用，出于性能的考虑，也希望它们是超亲密关系；

4. 两个容器或者是应用，它们需要共享某些 Linux Namespace。最简单常见的一个例子，就是我有一个容器需要加入另一个容器的 Network Namespace。这样我就能看到另一个容器的网络设备，和它的网络信息。

**Pod 这样的概念设计解决了两个问题**：

1. 我们怎么去描述超亲密关系；

2. 我们怎么去对超亲密关系的容器或者说是业务去做统一调度

## Pod 的实现机制

### 1. 共享网络

1. 通过 Infra Container 的方式共享同一个 Network Namespace

2. 直接使用 localhost 进行通信

3. 看到的网咯设备跟 Infra 容器看到的完全一样

4. 一个 Pod 只有一个 IP 地址，也就是这个 Pod 的 Network Namespace 对应的 IP 地址

5. 整个 Pod 的生命周期跟 Infra 容器一致，而与容器 A 和 A 无关

### 2. 共享存储

shared-data 对应在宿主机上的目录会被同时绑定挂载进了上述两个容器当中

## 详解容器设计模式

### 容器设计模式：Sidecar

通过在 Pod 里定义专门容器，来执行主业务容器需要的辅助工作

优势：将辅助功能同主业务容器解耦，实现独立发布和能力重用

## 总结

- Pod 是 Kubernetes 项目里实现“容器设计模式”的核心机制；

- “容器设计模式”是 Google Borg 的大规模容器集群管理最佳实践之一，也是 Kubernetes 进行复杂应用编排的基础依赖之一；

- 所有“设计模式”的本质都是：解耦和重用。
