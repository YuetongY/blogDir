[TOC]

---

####任务描述

本关任务：完成 Hyperledger Fabric 网络中链码安装、实例化、查询和调用。

####相关知识

完成第一关内容后，我们对链码已经有了一个基础的认识，下面利用 `fabric-samples` 提供的示例链码来进行实践。

- 检查当前节点（默认 `peer0.example.com`）已加入哪些通道中：

```shell
peer channel list
```

执行成功后终端会输出如下日志信息（如果日志没有显示 `mychannel`，则先用 `exit` 退出容器，再进入容器后运行上面命令）：

<br>

![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1gbxgz6ya2cj317r034jrr.jpg)

<br>

上面所示的输出内容，说明当前节点已成功加入一个名为 `mychannel` 的应用通道中。`Peer` 加入应用通道后，可以执行链码调用的相关操作，并进行测试。如果 `Peer` 节点没有加入通道中，则先将当前的 `Peer` 节点加入已创建的应用通道中。

#####安装链码
调用链码处理交易之前必须将其部署到 `Peer` 节点上，实现步骤如下：

1. 将其安装在指定的 `Peer` 节节点上。

2. 安装完成后对其进行实例化。

完成以上步骤后才可以调用链码处理交易（查询或执行事务）。

使用 `install` 命令安装链码：

```shell
peer chaincode install -n mycc -v 1.0 -p github.com/chaincode/chaincode_example02/go/
```

**参数说明**：

- `-n`：指定要安装的链码的名称。

- `-v`：指定链码的版本。

- `—p`：指定要安装的链码所在的路径。

命令执行完成后输出如下内容，则说明指定的链码被成功安装至 `Peer` 节点中：

<br>

![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1gbxh6zmf6yj314m04pjsd.jpg)

<br>

注意：链码需要根据指定的背书策略安装再需要背书的所有 `Peer` 节点中。

#####实例化链码

链码安装完成后并不能立刻使用，需要对已安装的链码进行实例化操作。

使用 `instantiate` 命令实例化链码，实例化链码成功后会启动一个链码容器用来为链码执行提供环境支持：

执行如下命令实例化链码，初始化两个账户 `a` 和 `b`，其中 `a` 账户余额为 100，`b` 账户余额为 200。

```shell
peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n mycc -v 1.0 -c '{"Args":["init","a","100","b","200"]}' -P "OR('Org1MSP.peer','Org2MSP.peer')"
```

**参数说明**：

- `-o`：指定 `Orderer` 节点地址。

- `--tls`：开启 `TLS` 验证。

- `--cafile`：指定 `TLS_CA` 证书的所在路径。

- `-n`：指定要实例化的链码名称，必须与安装时指定的链码名称相同。

- `-v`：指定要实例化的链码的版本号，必须与安装时指定的链码版本号相同。

- `-C`：指定通道名称。

- `-c`：指定实例化链码时所需的参数。

- `-P`：指定交易的背书策略（即由哪些 `Peer` 节点进行背书签名）。

执行命令后输出如下日志信息，说明实例化已完成，用户可想网络中发起交易：

<br>

![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1gbxhcxvxloj314l04kjsi.jpg)

<br>

注意：链码需要安装在多个背书的 `Peer` 节点中，但实例化只需要执行一次。

#####查询链码

链码部署成功之后，可以通过特定的命令调用链码，从而发起交易或查询请求，对分布式账本中的数据进行操作或检索。

使用 `query` 命令查询链码，查询账户 `a` 余额：

```shell
peer chaincode query -C mychannel -n mycc -c '{"Args":["query","a"]}'
```

**参数说明**：

- `-n`：指定要调用的链码名称。

- `-C`：指定通道名称。

- `-c`：指定调用链码时所需要的参数。

执行成功后输出如下日志信息，账户 `a` 余额为 100：

<br>

![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1gbxhmaflwqj3148034mxh.jpg)

<br>

#####调用链码

1. 发起转账交易

    如果要发起交易，则需要开启 `TLS` 验证并指定对应的证书路径，且在调用相应链码函数时须根据不同的实际情况指定相应的所需参数。

    使用 `invoke` 命令调用链码，从账户 `a` 中转移 10 给账户 `b`：

    ```shell
    peer chaincode invoke -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n mycc -c '{"Args":["invoke","a","b","10"]}'
    ```

    **参数说明**：

    - `-o`：指定 `Orderer` 节点地址。

    - `--tls`：开启 `TLS` 验证。

    - `--cafile`：指定 `TLS_CA` 证书的所在路径。

    - `-n`：指定链码名称。

    - `-C`：指定通道名称。

    - `-c`：指定调用链码时所需的参数。

    命令执行完后输出如下日志信息，说明链码调用成功且交易请求被成功处理：

    <br>

    ![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1gbxhqsae0aj314f04n755.jpg)

    <br>

2. 查询账户 `a` 的金额

    交易执行完毕之后，为了验证交易是否被正确执行，可以再次执行查询命令，根据输出的查询结果判断交易是否正确。

    执行查询账户 `a` 的命令：

    ```shell
    peer chaincode query -C mychannel -n mycc -c '{"Args":["query","a"]}'
    ```

    查询成功输出如下日志信息，余额为 90：

    <br>

    ![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1gbxhtixy4kj314h03fq3a.jpg)

    <br>

####编程要求

按要求完成本关卡内容后，点击评测即可。平台会检测 `docker ps | awk '{print $3}' | sort` 输出的分布式网络节点结构是否正确，以及是否包含最新启动的链码容器。

---
开始你的任务吧，祝你成功！


```go
cd /opt/go/src/github.com/hyperledger/fabric/scripts/fabric-samples/first-network/
chmod 755 /opt/go/src/github.com/hyperledger/fabric/scripts/fabric-samples/bin/cryptogen
# 创建符号链接修复 go 在 linux 环境中的依赖项
mkdir /lib64
ln -s /lib/libc.musl-x86_64.so.1 /lib64/ld-linux-x86-64.so.2
# 生成指定拓扑结构的网络组织结构和身份证书
../bin/cryptogen generate --config=./crypto-config.yaml

# 设置 configtxgen 工具权限
chmod 755 /opt/go/src/github.com/hyperledger/fabric/scripts/fabric-samples/bin/configtxgen
# 生成创世区块文件（注意这里需要用到第一关生成的组织结构和身份证书文件；如果出错则重新运行第一关中使用过的命令）
../bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block
# 生成应用通道交易配置文件
../bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID mychannel
# 为 Org1 生成锚节点更新配置文件
../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID mychannel -asOrg Org1MSP
# 为 Org2 生成锚节点更新配置文件
../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID mychannel -asOrg Org2MSP

# 切换路径
cd /opt/hyperledger-fabric-images
# 加载镜像
docker load -i fabric-baseos.tar
docker load -i fabric-ccenv.tar
docker load -i fabric-orderer.tar
docker load -i fabric-peer.tar
docker load -i fabric-tools.tar
# 更新镜像 tag
docker tag hyperledger/fabric-ccenv:1.4.0 hyperledger/fabric-ccenv:latest
docker tag hyperledger/fabric-orderer:1.4.0 hyperledger/fabric-orderer:latest
docker tag hyperledger/fabric-peer:1.4.0 hyperledger/fabric-peer:latest
docker tag hyperledger/fabric-tools:1.4.0 hyperledger/fabric-tools:latest
# 切换路径
cd /opt/go/src/github.com/hyperledger/fabric/scripts/fabric-samples/first-network/
# 设置工具权限
chmod -R 755 /opt/go/src/github.com/hyperledger/fabric/scripts/fabric-samples/bin/
# 启动 Hyperledger Fabric 网络的所有节点
# （注意这里需要用到第一、二关生成的所有文件；如果出错则重新运行第一、二关中使用过的命令）
docker-compose -f docker-compose-cli.yaml up -d

# 进入 cli 容器内部（注意这里需要用到前三关生成的所有文件和 Docker 容器；如果出错则重新运行前三关中使用过的命令）
docker exec -it cli /bin/bash
# 创建通道
peer channel create -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/channel.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem
# 将节点加入应用通道
peer channel join -b mychannel.block
# 使用 Org1 的管理员身份更新锚节点配置。执行如下命令：
peer channel update -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org1MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem
# 使用 Org2 的管理员身份更新锚节点配置。执行如下命令：
CORE_PEER_LOCALMSPID="Org2MSP"
CORE_PEER_ADDRESS=peer0.org2.example.com:7051
CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp
CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt
peer channel update -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org2MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem

# 链码安装、实例化、查询和调用
peer channel list
# 安装链码
peer chaincode install -n mycc -v 1.0 -p github.com/chaincode/chaincode_example02/go/
# 实例化链码
peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n mycc -v 1.0 -c '{"Args":["init","a","100","b","200"]}' -P "OR('Org1MSP.peer','Org2MSP.peer')"
# 查询链码
peer chaincode query -C mychannel -n mycc -c '{"Args":["query","a"]}'
# 发起交易
peer chaincode invoke -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n mycc -c '{"Args":["invoke","a","b","10"]}'
# 查询 a 账户的金额
peer chaincode query -C mychannel -n mycc -c '{"Args":["query","a"]}'
```