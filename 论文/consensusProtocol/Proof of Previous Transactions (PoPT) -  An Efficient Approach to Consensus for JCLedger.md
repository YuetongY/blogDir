# Proof of Previous Transactions (PoPT): An Efficient Approach to Consensus for JCLedger

## Abstract

JCLedger 是基于区块链的分布式账本，用于 JointCloud，可以提高不同云之间交换资源的可靠性和便利性。其实现最大的挑战是共识机制。现存的共识机制，如：PoW 和 Pos，需要大量的计算资源，且低吞吐量并伴有垄断的风险。

本文提出基于 PBFT 的共识算法 proof of previous transactions(POPT)，记账人由特殊的 hash 算法从确定数量的候选人中获得。获选人来自参与 JointCloud POPT 共识过程的用户。同时，本文针对并行计算提出了新的区块链结构，用于提高 JCLedger 的吞吐规模。提出一致性共识算法为不同记账人分配交易。模拟实验表明 PoPT 为不同算力的用户提供了同等的记账机会，并行记账可以使 JointCloud 中大规模和高频交易处理更有效。

## 1. INTRODUCTION

JointCloud 是新一代云计算模型，允许多云服务提供商(CSPs)跨云进行合作，促进小中型企业成为云服务顾客（CSCs）。

为了让 JointCloud 中云资源和价值交换更可信和便利，前人提出了 JCLedger，一个基于区块链的分布式账本。

共识算法从所有用户/节点中为每个区块选择记账人。账本/区块链由记账人打包的区块组成。

记账人选择的两条基本原则（为 JCLedger 设计共识算法的核心要素）：

1. 选择过程不能由少数人控制（不超过一半）

2. 选择结果是不可预测的

JointCloud 中参与者包括 cloud services brokers（CSBs），CSCs，和 CSPs。

在满足共识算法的基础需求外，我们需要以下完成以下约束：

1. 避免浪费算力

2. 为不同算力的用户提供同等记账的机会

3. 记账激励更合理

4. 处理大规模和高频交易

之前，我们为 JCLedger 提出过基于 POW 的共识算法 PoPF。本文我们提出另一个共识算法 proof of previous transaction（PoPT），满足以上约束，且更适合 JointCloud。PoPT 基于 PBFT，比 PoPf 更高效。PoPF 使用哈希函数从获选人中选择记账人，用新链结构进行并行记账。

## 2. BACKGROUND AND RELATED WORK

除了满足区块链中共识算法的基本需求外，我们希望共识算法可以使系统更有效。让系统更有效的主要因素是记账人。记账人的工作是打包区块，包括在广播区块前收集和验证交易。交易的验证包括发送人签名的验证，以及是否同其它交易冲突。==区块链系统的效率主要取决于记账交易的处理速度。==

## 3. DESIGN OF POPT

每个区块记账人根据用户的排名选取，排名取决于用户参与前一个交易的情况。

本章节包括：链结构，为每个区块确定区块数量，记账人选取，交易分配，区块打包与验证，基于 PBFT 的共识过程

### 3.1 Chain Structure

![image.png](https://ws1.sinaimg.cn/large/006alGmrly1g7osisze5ij30ht0fy0u8.jpg)

区块链由区块高度组成。不同区块高度可能有不同区块数。同一区块高度的区块有同样的区块头，区块头是上一个区块高度的哈希值。记账人为同一区块高度并行打包区块。同一区块高度中的区块排序取决于记账人 id 的哈希值。同一区块高度的区块组成一个大区快。

### 3.2 Number of Blocks for Each Block Height

一个区块对应一个记账人，每个区块高度的区块数量等于记账人的数量。由于交易数量会动态变化，所以不同区块高度有不同区块数量。尽管无法准确估计交易数量，但是我们可以可以通过前一个区块高度分析趋势，确定即将到来的区块高度需要多少记账人。

针对交易数量设置两个值：$m_l$ 表示下限，$m_u$ 即上限。假设 n 是区块中交易的数量，那么规则为：

1. n < $m_l$:  下一个区块高度减少一个记账人

2. n > $m_u$ ： 下一个区块高度增加一个记账人

### 3.3 记账人选择

1. $R(x)$: 用户/结点 $x$ 排名

2. $F(x)$: 从上次成为记账人以来，用户/结点 $x$ 支付的费用

3. $M(x)$: 用户/结点 $x$ 成为记账人的次数

4. $hash(x)$: 字符串 $x$ 的哈希值

5. $cur\_header$: 当前 big-block's header 的哈希值

6. $str\_id_i$: 候选 $i$ 的 id（public key）

哈希函数 $hash(x + y)$ 中 “$+$” 表示字符串 $x$ 和 $y$ 的连接。这里存在两种类型的结点：普通结点和记账结点。记账结点需要存储整个账本。对于记账结点，$F(x)$ 和 $M(x)$ 可以根据历史数据简单计算出。每个用户的排名由下面公式计算：

$$R(x)=\frac{F(x)}{M(x)+1}$$

从该排名中将分数最高的 $n$ 个用户设为记账候选人。假设当前区块高度需要 $k$ 个记账人，下面公式描述如何通过一个哈希函数从候选人中选择 $k$ 个记账人：

$$h_{standard}=hash(cur\_header+str\_id_1+str\_id_2+...+str\_id_n)$$

$$h_{id}(i)=|hash(str\_id_i+R(i))-h\_{standard}|.$$

最小的 $k$ $h_{id}(i)s$ 一旦被发现，对应的候选人将成为记账人。一旦候选 $x$ 成为记账人，我们设置 $F(x)=0$ 和 $M(x)=M(x)+1，这将致使 $R(x)=0$。因此 $x$ 将无法成为候选人，直到他支付足够的费用。该规则有效保证候选人轮询，避免持续记账。

### 3.4 Assignment of Transactions

交易通过一致性哈希算法分配给不同记账人/区块。分配分为三步：

1. Hash Circle: 记账人和交易被映射到一个值空间，在该值空间中可以行程一个首尾圆。SHA256 是映射用的哈希算法，保证值空间范围从 $0$ - $2^{256}-1$

2. Map Accountants and Transactions to the Hash Circle: 函数值表示位于哈希圈中的位置。对记账人，记账人 id 和当前区块高度是函数的参数。此外，函数参数是交易交易发送人的 id。映射函数保证，在同一高度，来自同一发送人的交易将被分配给同一记账人。因此，双花问题得以避免。

3. Map Transactions to Accountants: 根据哈希圈的位置，交易分配给据它顺时针最近的记账人。记账人只能处理映射给它的交易。

图四是交易分配的例子。虚拟结点用于避免不平衡分配问题。

![image.png](https://ws1.sinaimg.cn/large/006alGmrly1g7pfomvbooj30zh0d4n12.jpg)

### 3.5 区块打包和验证

在交易打包进区块之前需要验证，发送账户余额以及签名。一个区块中交易数量是有限的。记账人必须及时打包和广播区鲁哀，否者无法通过验证，将被丢弃。

当用户收到一个区块，在添加区块当账本之前，需要先验证区块的合法性。验证分 7 步。

1. 发送者是否是记账人身份

2. 记账人签名是否正确

3. 根据分配规则判断区块中的交易是否属于记账人

4. block-header 是否是上一个区块高度的 big-block 哈希值

5. 区块中的所有交易是否合法

6. 交易的数量是否超出限制

7. 区块广播到达时间是否超出限制

如果区块通过验证，添加区块至分布式账本中，否者丢弃，并广播消息，取消打包区块记账人身份。我们将在之后讨论如何处理无效记账人。

### 3.6 PBFT_Based Consensus Process

BPFT 是容忍拜占庭错误的 replication 算法，可以处理 $1/3$ 恶意拜占庭 replicas。view 中选择的 primary 负责将请求多播到其他 replicas。对 JCLedger 来说，候选人代表 replica， 区块高度代表 view，记账人代表 primary(关于 primary、view、和replica 的介绍可以参考：[PBFT实用拜占庭容错算法深入详解](https://blog.csdn.net/TurkeyCock/article/details/81672759))。图 5 表示 JCLedger 中 PBFT 的用法：

![image.png](https://ws1.sinaimg.cn/large/006alGmrly1g7pgpbsk4rj30ib0he41m.jpg)

假设候选人（包括记账人）数量是 $n$，最大恶意拜占庭副本数是 $f$，那么$f=(n-1)/3$。所有诚实结点将广播合法区块。如果一个诚实结点确定记账人无效，那么所有其它诚实结点都会认为该记账结点无效。所有诚实结点所做的决定都是相同的。当结点从其它 $f+1$ 个不同结点接受到同一消息，它可以确定该消息来自诚实结点，因为恶意拜占庭结点数不超过 $f$。这里的消息代表一个区块或者是无效记账人的判断结果。

![image.png](https://ws1.sinaimg.cn/large/006alGmrly1g7pq3lscwbj30iu0id77n.jpg)

基于 PBFT 共识过程如图 6. 记账人向全网广播打包好的区块，然后获选人验证区块并向其它候选人广播验证结果：如果候选人在约定的时间内收到 $f+1$ 个结论宣称区块有效，它可以向全网发送 commit。；否者，它发送消息宣称记账人无效。在接收到 $f+1$ 个 commit 之后，所有用户将添加区块至它们的 JCLedger 中，并宣称区块有效。记账人无效存在两种情况：

1. 广播的区块被证实非法

2. 存在来自同一记账人的两个不同合法区块（不同区块可能来自双花问题）。

如果有结点确定记账人无效，它们可以丢弃来自无效记账人的区块并全网广播。无效记账人将被惩罚（剥夺记账权力和清空财产），已分配给它的交易将再下一个区块高度被处理。恶意拜占庭候选人可以只广播虚假 commit，但是它起不了任何作用，因为数量不超过 $f$。PoPT 是由 PBFT、记账人选取、交易分配组成的混合协议。根据算法，记账人选取和交易分配是本地处理的两步。结点计算谁将成为记账人，并且根据它们持有的区块链分配交易，而不需要任何网络通信。如果两个结点拥有同样的数据，他们将计算获得同样的结果，包括记账人和交易分配方案。因此不需要考虑这两个步骤上的网络攻击（DDos 或者 poor network latency）。PoPT 中的网络攻击可以被防御，因为在假设下 PBFT 是安全的，这一点将在 Section V 讨论。尽管 PBFT 模型容易收到 Sybil 攻击（单节点可以创建或者操纵网络中大量身份，威胁网络），但是 PoPT 中 Sybil 攻击无法成功。这是因为结点在成为记账候选人之前需要支付足够的 fees。
